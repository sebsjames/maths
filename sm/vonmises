// -*- C++ -*-

#pragma once

#include <cmath>
#include <limits>
#include <sm/mathconst>
#include <sm/random>

// This code was copied and adapted from numpy! Thanks NumPy!
//
// rngu a uniform RNG generating numbers in range 0,1
// rngn a normal RNG
// mu mean of von mises
// kappa amplitude - whatever, the other one.
namespace sm::random
{
    double vonmises (rand_uniform<double>& rngu, rand_normal<double>& rngn, double mu, double kappa)
    {
        double s = 0.0;
        double U = 0.0, V = 0.0, W = 0.0, Y = 0.0, Z = 0.0;
        double result = 0.0, mod = 0.0;
        int neg = 0;
        if (std::isnan(kappa)) { return std::numeric_limits<double>::quiet_NaN(); }
        if (kappa < 1e-8) {
            /* Use a uniform for very small values of kappa (next_double() is the uniform rng) */
            return sm::mathconst<double>::pi * (2 * rngu.get() - 1); // -1 to 1
        } else {
            /* with double precision rho is zero until 1.4e-8 */
            if (kappa < 1e-5) {
                /*
                 * second order taylor expansion around kappa = 0
                 * precise until relatively large kappas as second order is 0
                 */
                s = (1. / kappa + kappa);
            } else {
                if (kappa <= 1e6) {
                    /* Path for 1e-5 <= kappa <= 1e6 */
                    double r = 1 + std::sqrt(1 + 4 * kappa * kappa);
                    double rho = (r - std::sqrt(2 * r)) / (2 * kappa);
                    s = (1 + rho * rho) / (2 * rho);
                } else {
                    /* Fallback to wrapped normal distribution for kappa > 1e6 */
                    result = mu + std::sqrt(1. / kappa) * rngn.get();
                    /* Ensure result is within bounds */
                    if (result < -sm::mathconst<double>::pi) {
                        result += sm::mathconst<double>::two_pi;
                    }
                    if (result > sm::mathconst<double>::pi) {
                        result -= sm::mathconst<double>::two_pi;
                    }
                    return result;
                }
            }

            while (1) {
                U = rngu.get();
                Z = cos(sm::mathconst<double>::pi * U);
                W = (1 + s * Z) / (s + Z);
                Y = kappa * (s - W);
                V = rngu.get();
                /*
                 * V==0.0 is ok here since Y >= 0 always leads
                 * to accept, while Y < 0 always rejects
                 */
                if ((Y * (2 - Y) - V >= 0) || (std::log(Y / V) + 1 - Y >= 0)) {
                    break;
                }
            }

            U = rngu.get();

            result = std::acos(W);
            if (U < 0.5) {
                result = -result;
            }
            result += mu;
            neg = (result < 0);
            mod = std::fabs (result);
            mod = (std::fmod (mod + sm::mathconst<double>::pi, sm::mathconst<double>::two_pi) - sm::mathconst<double>::pi);
            if (neg) { mod *= -1; }

            return mod;
        }
    }
} // namespace
