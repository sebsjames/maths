// -*- C++ -*-
/*!
 * This file is part of sebsjames/maths, a library of maths code for modern C++
 *
 * See https://github.com/sebsjames/maths
 *
 * \file
 *
 * A matrix class
 *
 * \author Seb James
 * \date 2019
 * Initial code author, maintenance
 *
 * \author Alex Blenkinsop
 * \date 2025
 * Improvements to methods that specify rotations and translations
 */
#pragma once

#include <cstdint>
#include <array>
#include <string>
#include <sstream>
#include <iostream>
#include <type_traits>
#include <initializer_list>
#include <complex>

#include <sm/mathconst>
#include <sm/quaternion>
#include <sm/vec>
#include <sm/constexpr_math>
#include <sm/mat33>
#include <sm/polysolve>

namespace sm
{
    // Forward declare class and stream operator
    template <typename F, uint32_t Nr, uint32_t Nc = Nr> requires std::is_floating_point_v<F> struct mat;
    template <typename F, uint32_t Nr, uint32_t Nc = Nr> std::ostream& operator<< (std::ostream&, const mat<F, Nr, Nc>&);

    /*!
     * A more general purpose mat class. Should this be a square class still?
     *
     * \templateparam F The floating point type in which to store the mat44's data.
     */
    template <typename F, uint32_t Nr, uint32_t Nc = Nr> requires std::is_floating_point_v<F>
    struct mat
    {
        //! Default constructor
        constexpr mat() noexcept { this->set_identity(); }
        //! Construct from a mat33 rotation matrix
        constexpr mat (const sm::mat<F, 3>& other) noexcept
        {
            this->arr[0] = other[0];
            this->arr[1] = other[1];
            this->arr[2] = other[2];
            this->arr[3] = F{0};

            this->arr[4] = other[3];
            this->arr[5] = other[4];
            this->arr[6] = other[5];
            this->arr[7] = F{0};

            this->arr[8] = other[6];
            this->arr[9] = other[7];
            this->arr[10] = other[8];
            this->arr[11] = F{0};

            this->arr[12] = F{0};
            this->arr[13] = F{0};
            this->arr[14] = F{0};
            this->arr[15] = F{1};
        }
        //! Initializer list construction
        constexpr mat (std::initializer_list<F> other) noexcept
        {
            unsigned int i = 0u;
            for (i = 0u; i < 16u; ++i) { this->arr[i] = F{0}; }
            i = 0u;
            for (F elem : other) {
                this->arr[i++] = elem;
                if (i == 16u) { break; } // only first 16 elements can be copied
            }
        }
        //! Construct with an array
        constexpr mat (const std::array<F, Nr * Nc>& other) noexcept { this->arr = other; }
        //! User-declared copy constructor
        constexpr mat (const mat<F, Nr, Nc>& other) noexcept : arr(other.arr) {}
        //! User-declared copy assignment constructor
        constexpr mat<F, Nr, Nc>& operator= (const mat<F, Nr, Nc>& other) noexcept
        {
            arr = other.arr;
            return *this;
        }
        //! Explicitly defaulted  move constructor
        mat (mat<F, Nr, Nc>&& other) noexcept = default;
        //! Explicitly defaulted move assignment constructor
        mat<F, Nr, Nc>& operator= (mat<F, Nr, Nc>&& other) noexcept = default;

        /*!
         * The transformation matrix data, arranged in column major format to be OpenGL
         * friendly.
         */
        alignas(std::array<F, Nr * Nc>) std::array<F, Nr * Nc> arr;

        //! Return a string representation of the passed-in column-major array
        static std::string str (const std::array<F, 16>& _arr) noexcept
        {
            std::stringstream ss;
            ss <<"[ "
            for (uint32_t r = 0; r < Nr; ++r) {
                if (r == 0) {
                    ss << " ";
                } else {
                    ss << "   ";
                }
                for (uint32_t c = 0; c < Nc; ++c) {
                    ss << arr[r * Nc + c];
                    if (c != Nc - 1) {
                        ss << ", ";
                    } else {
                        ss << " \n";
                    }
                }
            }
            ss << "]\n";
            return ss.str();
        }

        //! Return a string representation of the matrix
        std::string str() const noexcept { return this->str (this->arr); }

        //! Self-explanatory
        constexpr void set_identity() noexcept
        {
            this->arr.fill (F{0});
            this->arr[0] = F{1};
            this->arr[5] = F{1};
            this->arr[10] = F{1};
            this->arr[15] = F{1};
        }

        //! Return the identity matrix
        static constexpr mat<F, Nr, Nc> identity() noexcept { return sm::mat<F, Nr, Nc>{}; }

        //! Set *this from a transform matrix to transform a coordinate into the given coordinate basis set
        constexpr void frombasis_inplace (const sm::vec<F> bx, const sm::vec<F> by, const sm::vec<F> bz)
        {
            (*this) = sm::mat<F>::frombasis (bx, by, bz);
        }

        //! Create a transform matrix to transform a coordinate into the given coordinate basis set
        static constexpr mat<F> frombasis (const sm::vec<F> bx, const sm::vec<F> by, const sm::vec<F> bz)
        {
            sm::mat<F> m;

            m[0] = bx.x();
            m[1] = bx.y();
            m[2] = bx.z();
            m[3] = 0.0f;

            m[4] = by.x();
            m[5] = by.y();
            m[6] = by.z();
            m[7] = 0.0f;

            m[8] = bz.x();
            m[9] = bz.y();
            m[10] = bz.z();
            m[11] = 0.0f;

            m[12] = 0.0f;
            m[13] = 0.0f;
            m[14] = 0.0f;
            m[15] = 1.0f;

            return m;
        }

        //! Access elements of the matrix (returns ref, so not const)
        constexpr F& operator[] (const unsigned int idx) noexcept { return this->arr[idx]; }

        //! Access elements of the matrix with const promise
        constexpr F operator[] (const unsigned int idx) const noexcept { return this->arr[idx]; }

        //! Access a given row of the matrix
        constexpr sm::vec<F, Nc> row (unsigned int idx) const noexcept
        {
            sm::vec<F, Nc> r = {};
            if (idx >= Nc) { return r; }
            for () {
            }
            r[0] = this->arr[idx];
            r[1] = this->arr[idx+4];
            r[2] = this->arr[idx+8];
            r[3] = this->arr[idx+12];
            return r;
        }

        //! Access a given column of the matrix
        constexpr sm::vec<F, 4> col (unsigned int idx) const noexcept
        {
            sm::vec<F, 4> c = {F{0}, F{0}, F{0}, F{0}};
            if (idx > 3U) { return c; }
            idx *= 4U;
            c[0] = this->arr[idx];
            c[1] = this->arr[++idx];
            c[2] = this->arr[++idx];
            c[3] = this->arr[++idx];
            return c;
        }

        //! Apply pre-translation specified by vector @dv as this = m * this (pre-multiply)
        template<typename T, std::size_t N = 3> requires std::is_arithmetic_v<T> && (N == 3 || N == 4)
        constexpr void pretranslate (const sm::vec<T, N>& dv) noexcept
        {
            this->arr[12] += dv[0];
            this->arr[13] += dv[1];
            this->arr[14] += dv[2];
        }

        //! Apply pre-translation specified by vector @dv provided as array of three coordinates as
        //! this = m * this (pre-multiply)
        template<typename T, std::size_t N = 3> requires std::is_arithmetic_v<T> && (N == 3 || N == 4)
        constexpr void pretranslate (const std::array<T, N>& dv) noexcept
        {
            this->arr[12] += dv[0];
            this->arr[13] += dv[1];
            this->arr[14] += dv[2];
        }

        //! Apply pre-translation specified by coordinates @dx, @dy and @dz as this = m * this
        //! (pre-multiply)
        template<typename T> requires std::is_arithmetic_v<T>
        constexpr void pretranslate (const T& dx, const T& dy, const T& dz) noexcept
        {
            this->arr[12] += dx;
            this->arr[13] += dy;
            this->arr[14] += dz;
        }

        //! Apply translation specified by vector @dv as this = this * m (post-multiply)
        template<typename T, std::size_t N = 3> requires std::is_arithmetic_v<T> && (N == 3 || N == 4)
        constexpr void translate (const sm::vec<T, N>& dv) noexcept
        {
            mat<T> transarrat;
            transarrat[12] = dv[0];
            transarrat[13] = dv[1];
            transarrat[14] = dv[2];

            *this *= transarrat;
        }

        //! Apply translation specified by vector @dv provided as array of three coordinates as this
        //! = this * m (post-multiply)
        template<typename T, std::size_t N = 3> requires std::is_arithmetic_v<T> && (N == 3 || N == 4)
        constexpr void translate (const std::array<T, N>& dv) noexcept
        {
            mat<T> transarrat;
            transarrat[12] = dv[0];
            transarrat[13] = dv[1];
            transarrat[14] = dv[2];

            *this *= transarrat;
        }

        //! Apply translation specified by coordinates @dx, @dy and @dz. as this = this * m
        //! (post-multiply)
        template<typename T> requires std::is_arithmetic_v<T>
        constexpr void translate (const T& dx, const T& dy, const T& dz) noexcept
        {
            mat<T> transarrat;
            transarrat[12] = dx;
            transarrat[13] = dy;
            transarrat[14] = dz;

            *this *= transarrat;
        }

        //! Scaling transformation by individual dims
        template<typename T> requires std::is_arithmetic_v<T>
        constexpr void scale (const T& scl_x, const T& scl_y, const T& scl_z) noexcept
        {
            // This is the rotation matrix multiplied by a diagonalized matrix made from scl_x/y/z
            this->arr[0] *= scl_x;
            this->arr[1] *= scl_x;
            this->arr[2] *= scl_x;

            this->arr[4] *= scl_y;
            this->arr[5] *= scl_y;
            this->arr[6] *= scl_y;

            this->arr[8] *= scl_z;
            this->arr[9] *= scl_z;
            this->arr[10] *= scl_z;
        }

        //! Scaling transformation by vector. this = this * m (post-multiplication)
        template<typename T, std::size_t N = 3> requires std::is_arithmetic_v<T> && (N == 3 || N == 4)
        constexpr void scale (const sm::vec<T, N>& scl) noexcept
        {
            this->arr[0] *= scl[0];
            this->arr[1] *= scl[0];
            this->arr[2] *= scl[0];

            this->arr[4] *= scl[1];
            this->arr[5] *= scl[1];
            this->arr[6] *= scl[1];

            this->arr[8] *= scl[2];
            this->arr[9] *= scl[2];
            this->arr[10] *= scl[2];
        }

        //! Scaling transformation by array. this = this * m (post-multiplication)
        template<typename T, std::size_t N = 3> requires std::is_arithmetic_v<T> && (N == 3 || N == 4)
        constexpr void scale (const std::array<T, N>& scl) noexcept
        {
            this->arr[0] *= scl[0];
            this->arr[1] *= scl[0];
            this->arr[2] *= scl[0];

            this->arr[4] *= scl[1];
            this->arr[5] *= scl[1];
            this->arr[6] *= scl[1];

            this->arr[8] *= scl[2];
            this->arr[9] *= scl[2];
            this->arr[10] *= scl[2];
        }

        //! Scaling transformation by scalar. this = this * m (post-multiplication)
        template<typename T> requires std::is_arithmetic_v<T>
        constexpr void scale (const T& scl) noexcept
        {
            this->arr[0] *= scl;
            this->arr[1] *= scl;
            this->arr[2] *= scl;

            this->arr[4] *= scl;
            this->arr[5] *= scl;
            this->arr[6] *= scl;

            this->arr[8] *= scl;
            this->arr[9] *= scl;
            this->arr[10] *= scl;
        }

        //! Compute determinant for 4x4 matrix @cm
        static constexpr F determinant (const std::array<F, 16>& cm) noexcept
        {
            // Configure the 3x3 matrices that have to be evaluated to get the 4x4 det.
            std::array<F, 9> cm33;

            // First 3x3 matrix
            cm33[0] = cm[5];
            cm33[1] = cm[6];
            cm33[2] = cm[7];
            cm33[3] = cm[9];
            cm33[4] = cm[10];
            cm33[5] = cm[11];
            cm33[6] = cm[13];
            cm33[7] = cm[14];
            cm33[8] = cm[15];

            F det = cm[0] * mat33<F>::determinant (cm33);

            // Second 3x3
            cm33[0] = cm[1];
            cm33[1] = cm[2];
            cm33[2] = cm[3];
            cm33[3] = cm[9];
            cm33[4] = cm[10];
            cm33[5] = cm[11];
            cm33[6] = cm[13];
            cm33[7] = cm[14];
            cm33[8] = cm[15];

            det -= cm[4] * mat33<F>::determinant (cm33);

            // Third 3x3
            cm33[0] = cm[1];
            cm33[1] = cm[2];
            cm33[2] = cm[3];
            cm33[3] = cm[5];
            cm33[4] = cm[6];
            cm33[5] = cm[7];
            cm33[6] = cm[13];
            cm33[7] = cm[14];
            cm33[8] = cm[15];

            det += cm[8] * mat33<F>::determinant (cm33);

            // Final 3x3
            cm33[0] = cm[1];
            cm33[1] = cm[2];
            cm33[2] = cm[3];
            cm33[3] = cm[5];
            cm33[4] = cm[6];
            cm33[5] = cm[7];
            cm33[6] = cm[9];
            cm33[7] = cm[10];
            cm33[8] = cm[11];

            det -= cm[12] * mat33<F>::determinant (cm33);

            return det;
        }

        //! Compute determinant for this->arr
        constexpr F determinant() const noexcept { return mat<F>::determinant (this->arr); }

        /*!
         * The adjugate is the transpose of the cofactor matrix. Recipe:
         * 1. Get the cofactor matrix (with this->cofactor())
         * 2. Obtain the adjugate matrix by transposing the cofactor matrix
         */
        constexpr std::array<F, 16> adjugate() const noexcept { return mat<F>::transpose (this->cofactor()); }

        /*!
         * Compute the cofactor matrix of this->arr. Recipe:
         * 1. Create matrix of minors
         * 2. Multiply matrix of minors by a checkerboard pattern to give the cofactor matrix
         */
        constexpr std::array<F, 16> cofactor() const noexcept
        {
            std::array<F, 16> cofac;

            // Keep to column-major format for all matrices. The elements of the matrix
            // of minors is found, but the cofactor matrix is populated, applying the
            // alternating pattern of +/- as we go.

            // 0.
            std::array<F, 9> minorElem;
            minorElem[0] = this->arr[5];
            minorElem[3] = this->arr[9];
            minorElem[6] = this->arr[13];

            minorElem[1] = this->arr[6];
            minorElem[4] = this->arr[10];
            minorElem[7] = this->arr[14];

            minorElem[2] = this->arr[7];
            minorElem[5] = this->arr[11];
            minorElem[8] = this->arr[15];

            cofac[0] = mat33<F>::determinant (minorElem);

            // 1. Next minor elem matrix has only 3 elements changed
            minorElem[0] = this->arr[4];
            minorElem[3] = this->arr[8];
            minorElem[6] = this->arr[12];
            cofac[1] = -mat33<F>::determinant (minorElem);

            // 2
            minorElem[1] = this->arr[5];
            minorElem[4] = this->arr[9];
            minorElem[7] = this->arr[13];
            cofac[2] = mat33<F>::determinant (minorElem);

            // 3
            minorElem[2] = this->arr[6];
            minorElem[5] = this->arr[10];
            minorElem[8] = this->arr[14];
            cofac[3] = -mat33<F>::determinant (minorElem);

            // 4.
            minorElem[0] = this->arr[1];
            minorElem[3] = this->arr[9];
            minorElem[6] = this->arr[13];

            minorElem[1] = this->arr[2];
            minorElem[4] = this->arr[10];
            minorElem[7] = this->arr[14];

            minorElem[2] = this->arr[3];
            minorElem[5] = this->arr[11];
            minorElem[8] = this->arr[15];

            cofac[4] = -mat33<F>::determinant (minorElem);

            // 5.
            minorElem[0] = this->arr[0];
            minorElem[3] = this->arr[8];
            minorElem[6] = this->arr[12];
            cofac[5] = mat33<F>::determinant (minorElem);

            // 6.
            minorElem[1] = this->arr[1];
            minorElem[4] = this->arr[9];
            minorElem[7] = this->arr[13];
            cofac[6] = -mat33<F>::determinant (minorElem);

            // 7.
            minorElem[2] = this->arr[2];
            minorElem[5] = this->arr[10];
            minorElem[8] = this->arr[14];
            cofac[7] = mat33<F>::determinant (minorElem);

            // 8.
            minorElem[0] = this->arr[1];
            minorElem[3] = this->arr[5];
            minorElem[6] = this->arr[13];

            minorElem[1] = this->arr[2];
            minorElem[4] = this->arr[6];
            minorElem[7] = this->arr[14];

            minorElem[2] = this->arr[3];
            minorElem[5] = this->arr[7];
            minorElem[8] = this->arr[15];

            cofac[8] = mat33<F>::determinant (minorElem);

            // 9.
            minorElem[0] = this->arr[0];
            minorElem[3] = this->arr[4];
            minorElem[6] = this->arr[12];
            cofac[9] = -mat33<F>::determinant (minorElem);

            // 10.
            minorElem[1] = this->arr[1];
            minorElem[4] = this->arr[5];
            minorElem[7] = this->arr[13];
            cofac[10] = mat33<F>::determinant (minorElem);

            // 11.
            minorElem[2] = this->arr[2];
            minorElem[5] = this->arr[6];
            minorElem[8] = this->arr[14];
            cofac[11] = -mat33<F>::determinant (minorElem);

            // 12.
            minorElem[0] = this->arr[1];
            minorElem[3] = this->arr[5];
            minorElem[6] = this->arr[9];

            minorElem[1] = this->arr[2];
            minorElem[4] = this->arr[6];
            minorElem[7] = this->arr[10];

            minorElem[2] = this->arr[3];
            minorElem[5] = this->arr[7];
            minorElem[8] = this->arr[11];

            cofac[12] = -mat33<F>::determinant (minorElem);

            // 13.
            minorElem[0] = this->arr[0];
            minorElem[3] = this->arr[4];
            minorElem[6] = this->arr[8];
            cofac[13] = mat33<F>::determinant (minorElem);

            // 14.
            minorElem[1] = this->arr[1];
            minorElem[4] = this->arr[5];
            minorElem[7] = this->arr[9];
            cofac[14] = -mat33<F>::determinant (minorElem);

            // 15.
            minorElem[2] = this->arr[2];
            minorElem[5] = this->arr[6];
            minorElem[8] = this->arr[10];
            cofac[15] = mat33<F>::determinant (minorElem);

            return cofac;
        }

        //! Compute the trace of the matrix (the sum of the diagonal elements)
        constexpr F trace() const noexcept { return this->arr[0] + this->arr[5] + this->arr[10] + this->arr[15]; }

        /*!
         * Return the inverse matrix.
         *
         * Implement inversion using determinant method. inverse is (1/det) x adjugate
         * matrix.
         *
         * 1. Compute determinant of this->arr (if 0, then there's no inverse)
         * 2. Obtain the adjugate matrix
         * 3. Get the inverse by multiplying 1/determinant by the adjugate
         */
        constexpr mat<F> inverse() const noexcept
        {
            F det = this->determinant();
            mat<F> m;
            if (det == F{0}) {
                // The transform matrix has no inverse (determinant is 0)
                m.arr.fill (F{0});
            } else {
                m.arr = this->adjugate();
                m *= (F{1} / det);
            }
            return m;
        }

        /*!
         * Turn the matrix into its inverse.
         *
         * Implement inversion using determinant method. inverse is (1/det) x adjugate
         * matrix.
         *
         * 1. Compute determinant of this->arr (if 0, then there's no inverse)
         * 2. Obtain the adjugate matrix
         * 3. Get the inverse by multiplying 1/determinant by the adjugate
         */
        constexpr void inverse_inplace() noexcept
        {
            F det = this->determinant();
            if (det == F{0}) {
                // The transform matrix has no inverse (determinant is 0)
                this->arr.fill (F{0});
            } else {
                this->arr = this->adjugate();
                *this *= (F{1} / det);
            }
        }

        /*!
         * Compute the eigenvalues of this 4x4 matrix.
         * Returns a vector of 4 complex eigenvalues.
         *
         * Uses the Faddeev-LeVerrier algorithm to compute the characteristic
         * polynomial det(A - lambda*I) = 0, then solves for roots using polysolve.
         */
        sm::vec<std::complex<F>, 4> eigenvalues() const noexcept
        {
            // Use Faddeev-LeVerrier algorithm to get characteristic polynomial
            sm::vvec<F> coeffs(5, F{0});
            coeffs[4] = F{1};  // Leading coefficient

            sm::mat<F> M;

            for (int k = 1; k <= 4; ++k) {
                M = (*this) * M;  // M_k = A * M_{k-1}, where M_0 = I
                F trace = M.trace();
                coeffs[4 - k] = -trace / F(k);

                if (k < 4) {
                    // M = M_k + c_{n-k} * I
                    M[0] += coeffs[4 - k];
                    M[5] += coeffs[4 - k];
                    M[10] += coeffs[4 - k];
                    M[15] += coeffs[4 - k];
                }
            }

            sm::vvec<std::complex<F>> roots_vec = sm::polysolve::solve<F> (coeffs);

            // Convert from sm::vvec to sm::vec for return type
            sm::vec<std::complex<F>, 4> roots;
            roots[0] = roots_vec[0];
            roots[1] = roots_vec[1];
            roots[2] = roots_vec[2];
            roots[3] = roots_vec[3];

            return roots;
        }

        /*!
         * Find an eigenvector for a given eigenvalue.
         * Returns a normalized eigenvector as a complex vector.
         */
        sm::vec<std::complex<F>, 4> eigenvector (const std::complex<F>& lambda) const noexcept
        {
            constexpr F my_epsilon = F{1e-14};

            // Form (A - lambda * I)
            std::array<std::complex<F>, 16> Aarrinus_lambda = {};
            for (int i = 0; i < 16; ++i) {
                Aarrinus_lambda[i] = std::complex<F>{ this->arr[i], F{0} };
            }
            Aarrinus_lambda[0] -= lambda;
            Aarrinus_lambda[5] -= lambda;
            Aarrinus_lambda[10] -= lambda;
            Aarrinus_lambda[15] -= lambda;

            sm::vec<std::complex<F>, 4> v = {};

            // Simplified null space finder: use last component as free variable
            v[3] = std::complex<F>{ F{1}, F{0} };

            // Back substitute (simplified approach)
            if (std::abs (Aarrinus_lambda[10]) > my_epsilon) {
                v[2] = -Aarrinus_lambda[14] / Aarrinus_lambda[10];
            } else {
                v[2] = std::complex<F>{ F{0}, F{0} };
            }

            if (std::abs (Aarrinus_lambda[5]) > my_epsilon) {
                v[1] = -(Aarrinus_lambda[9] * v[2] + Aarrinus_lambda[13]) / Aarrinus_lambda[5];
            } else {
                v[1] = std::complex<F>{ F{0}, F{0} };
            }

            if (std::abs (Aarrinus_lambda[0]) > my_epsilon) {
                v[0] = -(Aarrinus_lambda[4] * v[1] + Aarrinus_lambda[8] * v[2] + Aarrinus_lambda[12]) / Aarrinus_lambda[0];
            } else {
                v[0] = std::complex<F>{ F{1}, F{0} };
            }

            // Normalize
            F norm = std::sqrt (std::norm (v[0]) + std::norm (v[1]) + std::norm (v[2]) + std::norm (v[3]));
            if (norm > my_epsilon) { v /= norm; }

            return v;
        }

        /*!
         * Compute both eigenvalues and their corresponding eigenvectors.
         * Returns a vector of 4 pairs, each containing an eigenvalue and its eigenvector.
         */
        struct eigenpair
        {
            std::complex<F> eigenvalue = {};
            sm::vec<std::complex<F>, 4> eigenvector = {};
        };

        sm::vec<eigenpair, 4> eigenpairs() const noexcept
        {
            sm::vec<eigenpair, 4> pairs = {};
            sm::vec<std::complex<F>, 4> lambdas = this->eigenvalues();

            pairs[0].eigenvalue = lambdas[0];
            pairs[0].eigenvector = this->eigenvector (lambdas[0]);

            pairs[1].eigenvalue = lambdas[1];
            pairs[1].eigenvector = this->eigenvector (lambdas[1]);

            pairs[2].eigenvalue = lambdas[2];
            pairs[2].eigenvector = this->eigenvector (lambdas[2]);

            pairs[3].eigenvalue = lambdas[3];
            pairs[3].eigenvector = this->eigenvector (lambdas[3]);

            return pairs;
        }

        // Set this mat up as a reflection transformation. Any existing transformation in the mat will be lost.
        template <typename T> requires std::is_arithmetic_v<T>
        static constexpr mat<F> reflection (const sm::vec<T, 3>& p, const sm::vec<T, 3> n) noexcept
        {
            // Order of operations: Translate -p (so that we reflect about 0), reflect about 0, untranslate.
            sm::mat<F> tr1;
            tr1.translate (-p);
            sm::mat<F> refl (sm::mat33<F>::reflection (n));
            sm::mat<F> tr2;
            tr2.translate (p);
            return /* tr1.inverse() or tr2 */ tr2 * refl * tr1;
        }

        /*!
         * Place a pure rotation q (with no translation) into a mat<F> and return it.
         *
         * This algorithm was obtained from:
         * http://www.j3d.org/matrix_faq/matrfaq_latest.html#Q54 (but was it transposed?
         * seems so. See also https://www.songho.ca/opengl/gl_quaternion.html#overview
         * and https://danceswithcode.net/engineeringnotes/quaternions/quaternions.html)
         */
        template <typename T> requires std::is_arithmetic_v<T>
        static constexpr mat<F> pure_rotation (const sm::quaternion<T>& q) noexcept
        {
            const F qx = static_cast<F>(q.x);
            const F qy = static_cast<F>(q.y);
            const F qz = static_cast<F>(q.z);
            const F qw = static_cast<F>(q.w);
            const F f2x = qx * F{2};
            const F f2y = qy * F{2};
            const F f2z = qz * F{2};
            const F f2xw = f2x * qw;
            const F f2yw = f2y * qw;
            const F f2zw = f2z * qw;
            const F f2xx = f2x * qx;
            const F f2xy = f2x * qy;
            const F f2xz = f2x * qz;
            const F f2yy = f2y * qy;
            const F f2yz = f2y * qz;
            const F f2zz = f2z * qz;

            mat<F> m;
            m[0]  = F{1} - (f2yy + f2zz);
            m[1]  =         f2xy + f2zw;
            m[2]  =         f2xz - f2yw;
            m[3]  = F{0};
            m[4]  =         f2xy - f2zw;
            m[5]  = F{1} - (f2xx + f2zz);
            m[6]  =         f2yz + f2xw;
            m[7]  = F{0};
            m[8]  =         f2xz + f2yw;
            m[9]  =         f2yz - f2xw;
            m[10] = F{1} - (f2xx + f2yy);
            m[11] = F{0};
            m[12] = F{0};
            m[13] = F{0};
            m[14] = F{0};
            m[15] = F{1};

            return m;
        }

        //! Apply the rotation q to this as a pre-multiplication: this = R * this
        template <typename T> requires std::is_arithmetic_v<T>
        constexpr void prerotate (const sm::quaternion<T>& q) noexcept { *this = this->pure_rotation (q) * *this; }

        /*!
         * Pre-rotate an angle theta radians about axis (specified as std::array). By default, axis
         * is not required to be normalized because quaternion::rotate will do this.
         *
         * Result is this = R * this  (rotation pre-multiplies)
         *
         * \tparam renorm If true, renormalize axis to length 1, if false, assume axis has already
         * been renormalized
         *
         * \tparam T type for operations, usually compiler-detected from axis and theta
         *
         * \tparam N Number of elements in the axis vector, compiler-detected from axis. Allows
         * passing of 3D and (3+1)D vectors
         */
        template <bool renorm = true, typename T = F, std::size_t N = 3> requires std::is_arithmetic_v<T> && (N == 3 || N == 4)
        constexpr void prerotate (const std::array<T, N>& axis, const T& theta) noexcept
        {
            sm::quaternion<T> q;
            q.template rotate<std::array<T, N>, renorm> (axis, theta);
            this->prerotate<T> (q);
        }

        /*!
         * Pre-rotate an angle theta radians about axis (specified as sm::vec). By default, axis is
         * not required to be normalized because quaternion::rotate will do this.
         *
         * Result is this = R * this  (rotation pre-multiplies)
         *
         * \tparam renorm If true, renormalize axis to length 1, if false, assume axis has already
         * been renormalized
         *
         * \tparam T type for operations, usually compiler-detected from axis and theta
         *
         * \tparam N Number of elements in the axis vector, compiler-detected from axis. Allows
         * passing of 3D and (3+1)D vectors
         */
        template <bool renorm = true, typename T = F, std::size_t N = 3> requires std::is_arithmetic_v<T> && (N == 3 || N == 4)
        constexpr void prerotate (const sm::vec<T, N>& axis, const T& theta) noexcept
        {
            sm::quaternion<T> q;
            q.template rotate<sm::vec<T, N>, renorm> (axis, theta);
            this->prerotate<T> (q);
        }

        //! Rotation by post-multiplication of a pure rotation matrix: this = this * R
        template <typename T> requires std::is_arithmetic_v<T>
        constexpr void rotate (const sm::quaternion<T>& q) noexcept { *this *= this->pure_rotation (q); }

        /*!
         * Rotate an angle theta radians about axis (specified as std::array). By default, the axis
         * is not required to be normalized because quaternion::rotate will do this.
         *
         * Result: this = this * R (post-multiplication)
         *
         * \tparam renorm If true, renormalize axis to length 1, if false, assume axis has already
         * been renormalized
         *
         * \tparam T type for operations, usually compiler-detected from axis and theta
         *
         * \tparam N Number of elements in the axis vector, compiler-detected from axis. Allows
         * passing of 3D and (3+1)D vectors
         */
        template <bool renorm = true, typename T = F, std::size_t N = 3> requires std::is_arithmetic_v<T> && (N == 3 || N == 4)
        constexpr void rotate (const std::array<T, N>& axis, const T& theta) noexcept
        {
            sm::quaternion<T> q;
            q.template rotate<std::array<T, N>, renorm> (axis, theta);
            this->rotate<T> (q);
        }

        /*!
         * Rotate an angle theta radians about axis (specified as sm::vec). By default, the axis is
         * not required to be normalized because quaternion::rotate will do this.
         *
         * Result: this = this * R (post-multiplication)
         *
         * \tparam renorm If true, renormalize axis to length 1, if false, assume axis has already
         * been renormalized
         *
         * \tparam T type for operations, usually compiler-detected from axis and theta
         *
         * \tparam N Number of elements in the axis vector, compiler-detected from axis. Allows
         * passing of 3D and (3+1)D vectors
         */
        template <bool renorm = true, typename T = F, std::size_t N = 3> requires std::is_arithmetic_v<T> && (N == 3 || N == 4)
        constexpr void rotate (const sm::vec<T, N>& axis, const T& theta) noexcept
        {
            sm::quaternion<T> q;
            q.template rotate<sm::vec<T, N>, renorm> (axis, theta);
            this->rotate<T> (q);
        }

        //! Returns the linear part of the 4x4 matrix (the top left 3x3 matrix)
        constexpr sm::mat33<F> linear() const noexcept
        {
            sm::mat33<F> m;

            m[0] = this->arr[0];
            m[1] = this->arr[1];
            m[2] = this->arr[2];
            m[3] = this->arr[4];
            m[4] = this->arr[5];
            m[5] = this->arr[6];
            m[6] = this->arr[8];
            m[7] = this->arr[9];
            m[8] = this->arr[10];

            return m;
        }

        //! Returns the translation part of the 4x4 matrix (top three rows of last column)
        constexpr sm::vec<F, 3> translation() const noexcept
        {
            return { this->arr[12], this->arr[13], this->arr[14] };
        }

        /*!
         * Returns the rotation part of the 4x4 matrix (the top left 3x3 matrix, as returned by
         * mat::linear) as a quaternion.
         *
         * This does the equivalent of this->linear().rotation() (that is, you can find
         * mat33::rotation which is the same as this function).
         *
         * It assumes that your 4x4 matrix encodes rotations without scaling. You could use
         * rotationarrat44().rotation() to first exclude a uniform or pre-applied scaling.
         *
         * It does *not* check that the matrix determinant is 1 (you could do that first if you need
         * to).
         *
         * It does *not* normalize the generated quaternion before returning it (you could do that
         * afterwards if you need to).
         *
         * Hat tip for the algorithm:
         * https://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/
         */
        constexpr sm::quaternion<F> rotation() const noexcept
        {
            sm::quaternion<F> q;

            F tr = arr[0] + arr[5] + arr[10];

            if (tr > F{0}) {
                F S = sm::cem::sqrt (tr + F{1}) * F{2}; // S=4*qw
                q.w = F{0.25} * S;
                q.x = (arr[6] - arr[9]) / S;
                q.y = (arr[8] - arr[2]) / S;
                q.z = (arr[1] - arr[4]) / S;
            } else if ((arr[0] > arr[5]) && (arr[0] > arr[10])) {
                F S = sm::cem::sqrt (F{1} + arr[0] - arr[5] - arr[10]) * F{2}; // S=4*qx
                q.w = (arr[6] - arr[9]) / S;
                q.x = F{0.25} * S;
                q.y = (arr[4] + arr[1]) / S;
                q.z = (arr[8] + arr[2]) / S;
            } else if (arr[5] > arr[10]) {
                F S = sm::cem::sqrt (F{1} + arr[5] - arr[0] - arr[10]) * F{2}; // S=4*qy
                q.w = (arr[8] - arr[2]) / S;
                q.x = (arr[4] + arr[1]) / S;
                q.y = F{0.25} * S;
                q.z = (arr[9] + arr[6]) / S;
            } else {
                F S = sm::cem::sqrt (F{1} + arr[10] - arr[0] - arr[6]) * F{2}; // S=4*qz
                q.w = (arr[1] - arr[4]) / S;
                q.x = (arr[8] + arr[2]) / S;
                q.y = (arr[9] + arr[6]) / S;
                q.z = F{0.25} * S;
            }

            return q;
        }

        //! Obtain the rotation, excluding any uniform, or non-uniform-but-applied-before-rotations scaling.
        constexpr sm::mat33<F> rotationarrat33() const noexcept
        {
            sm::vec<F, 3> c0 = { arr[0], arr[1], arr[2] };
            sm::vec<F, 3> c1 = { arr[4], arr[5], arr[6] };
            sm::vec<F, 3> c2 = { arr[8], arr[9], arr[10] };
            c0 /= c0.length();
            c1 /= c1.length();
            c2 /= c2.length();
            sm::mat33<F> m = { c0[0], c0[1], c0[2], c1[0], c1[1], c1[2], c2[0], c2[1], c2[2] };
            return m;
        }

        //! Obtain the rotation, excluding any uniform, or non-uniform-but-applied-before-rotations scaling.
        constexpr sm::mat<F> rotationarrat44() const noexcept
        {
            sm::vec<F, 3> c0 = { arr[0], arr[1], arr[2] };
            sm::vec<F, 3> c1 = { arr[4], arr[5], arr[6] };
            sm::vec<F, 3> c2 = { arr[8], arr[9], arr[10] };
            c0 /= c0.length();
            c1 /= c1.length();
            c2 /= c2.length();
            sm::mat<F> m = {
                c0[0], c0[1], c0[2], F{0},
                c1[0], c1[1], c1[2], F{0},
                c2[0], c2[1], c2[2], F{0},
                F{0},  F{0},  F{0},  F{1}
            };
            return m;
        }

        //! Obtain scaling from this matrix, returning as a vector of scale factors
        constexpr sm::vec<F, 3> scaling_vec() const noexcept
        {
            return sm::vec<F, 3>{
                sm::cem::sqrt (arr[0] * arr[0] + arr[1] * arr[1] + arr[2] * arr[2]), // length of 1st col
                sm::cem::sqrt (arr[4] * arr[4] + arr[5] * arr[5] + arr[6] * arr[6]),
                sm::cem::sqrt (arr[8] * arr[8] + arr[9] * arr[9] + arr[10] * arr[10])
            };
        }

        //! Obtain scaling from this matrix, returning as a 3x3 mat33
        constexpr sm::mat33<F> scalingarrat33() const noexcept
        {
            sm::mat33<F> m = {
                sm::cem::sqrt (arr[0] * arr[0] + arr[1] * arr[1] + arr[2] * arr[2]),   F{0}, F{0},
                F{0}, sm::cem::sqrt (arr[4] * arr[4] + arr[5] * arr[5] + arr[6] * arr[6]),   F{0},
                F{0}, F{0}, sm::cem::sqrt (arr[8] * arr[8] + arr[9] * arr[9] + arr[10] * arr[10])
            };
            return m;
        }

        //! Obtain scaling from this matrix, returning as a 4x4 mat
        constexpr sm::mat<F> scalingarrat44() const noexcept
        {
            sm::mat<F> m = {
                sm::cem::sqrt (arr[0] * arr[0] + arr[1] * arr[1] + arr[2] * arr[2]),   F{0}, F{0}, F{0},
                F{0}, sm::cem::sqrt (arr[4] * arr[4] + arr[5] * arr[5] + arr[6] * arr[6]),   F{0}, F{0},
                F{0}, F{0}, sm::cem::sqrt (arr[8] * arr[8] + arr[9] * arr[9] + arr[10] * arr[10]), F{0},
                F{0}, F{0}, F{0},                                                                  F{1}
            };
            return m;
        }

        //! Add m2 to this matrix
        constexpr void operator+= (const mat<F>& m2) noexcept
        {
            for (unsigned int i = 0; i < 16; ++i) { this->arr[i] += m2.arr[i]; }
        }

        //! Return this + m2
        constexpr mat<F> operator+ (const mat<F>& m2) const noexcept
        {
            mat<F> m = { F{0} };
            for (unsigned int i = 0; i < 16; ++i) { m[i] = this->arr[i] + m2.arr[i]; }
            return m;
        }

        //! Add scalar to this matrix
        constexpr void operator+= (const F& f) noexcept
        {
            for (unsigned int i = 0; i < 16; ++i) { this->arr[i] += f; }
        }

        //! Return this + scalar
        constexpr mat<F> operator+ (const F& f) const noexcept
        {
            mat<F> m = { F{0} };
            for (unsigned int i = 0; i < 16; ++i) { m[i] = this->arr[i] + f; }
            return m;
        }

        //! Subtract m2 from this matrix
        constexpr void operator-= (const mat<F>& m2) noexcept
        {
            for (unsigned int i = 0; i < 16; ++i) { this->arr[i] -= m2.arr[i]; }
        }

        //! Return this - m2
        constexpr mat<F> operator- (const mat<F>& m2) const noexcept
        {
            mat<F> m = { F{0} };
            for (unsigned int i = 0; i < 16; ++i) { m[i] = this->arr[i] - m2.arr[i]; }
            return m;
        }

        //! Subtract scalar from this matrix
        constexpr void operator-= (const F& f) noexcept
        {
            for (unsigned int i = 0; i < 16; ++i) { this->arr[i] -= f; }
        }

        //! Return this - scalar
        constexpr mat<F> operator- (const F& f) const noexcept
        {
            mat<F> m = { F{0} };
            for (unsigned int i = 0; i < 16; ++i) { m[i] = this->arr[i] - f; }
            return m;
        }

        //! Right-multiply this->arr with m2
        constexpr void operator*= (const mat<F>& m2) noexcept
        {
            std::array<F, 16> m;
            // Top row
            m[0] = this->arr[0] * m2.arr[0] + this->arr[4] * m2.arr[1] + this->arr[8] * m2.arr[2] + this->arr[12] * m2.arr[3];
            m[4] = this->arr[0] * m2.arr[4] + this->arr[4] * m2.arr[5] + this->arr[8] * m2.arr[6] + this->arr[12] * m2.arr[7];
            m[8] = this->arr[0] * m2.arr[8] + this->arr[4] * m2.arr[9] + this->arr[8] * m2.arr[10] + this->arr[12] * m2.arr[11];
            m[12] = this->arr[0] * m2.arr[12] + this->arr[4] * m2.arr[13] + this->arr[8] * m2.arr[14] + this->arr[12] * m2.arr[15];
            // Second row
            m[1] = this->arr[1] * m2.arr[0] + this->arr[5] * m2.arr[1] + this->arr[9] * m2.arr[2] + this->arr[13] * m2.arr[3];
            m[5] = this->arr[1] * m2.arr[4] + this->arr[5] * m2.arr[5] + this->arr[9] * m2.arr[6] + this->arr[13] * m2.arr[7];
            m[9] = this->arr[1] * m2.arr[8] + this->arr[5] * m2.arr[9] + this->arr[9] * m2.arr[10] + this->arr[13] * m2.arr[11];
            m[13] = this->arr[1] * m2.arr[12] + this->arr[5] * m2.arr[13] + this->arr[9] * m2.arr[14] + this->arr[13] * m2.arr[15];
            // Third row
            m[2] = this->arr[2] * m2.arr[0] + this->arr[6] * m2.arr[1] + this->arr[10] * m2.arr[2] + this->arr[14] * m2.arr[3];
            m[6] = this->arr[2] * m2.arr[4] + this->arr[6] * m2.arr[5] + this->arr[10] * m2.arr[6] + this->arr[14] * m2.arr[7];
            m[10] = this->arr[2] * m2.arr[8] + this->arr[6] * m2.arr[9] + this->arr[10] * m2.arr[10] + this->arr[14] * m2.arr[11];
            m[14] = this->arr[2] * m2.arr[12] + this->arr[6] * m2.arr[13] + this->arr[10] * m2.arr[14] + this->arr[14] * m2.arr[15];
            // Bottom row
            m[3] = this->arr[3] * m2.arr[0] + this->arr[7] * m2.arr[1] + this->arr[11] * m2.arr[2] + this->arr[15] * m2.arr[3];
            m[7] = this->arr[3] * m2.arr[4] + this->arr[7] * m2.arr[5] + this->arr[11] * m2.arr[6] + this->arr[15] * m2.arr[7];
            m[11] = this->arr[3] * m2.arr[8] + this->arr[7] * m2.arr[9] + this->arr[11] * m2.arr[10] + this->arr[15] * m2.arr[11];
            m[15] = this->arr[3] * m2.arr[12] + this->arr[7] * m2.arr[13] + this->arr[11] * m2.arr[14] + this->arr[15] * m2.arr[15];

            this->arr.swap (m);
        }

        //! Right multiply this->arr with m2.arr.
        constexpr mat<F> operator* (const mat<F>& m2) const noexcept
        {
            mat<F> m;
            // Top row
            m.arr[0] = this->arr[0] * m2.arr[0] + this->arr[4] * m2.arr[1] + this->arr[8] * m2.arr[2] + this->arr[12] * m2.arr[3];
            m.arr[4] = this->arr[0] * m2.arr[4] + this->arr[4] * m2.arr[5] + this->arr[8] * m2.arr[6] + this->arr[12] * m2.arr[7];
            m.arr[8] = this->arr[0] * m2.arr[8] + this->arr[4] * m2.arr[9] + this->arr[8] * m2.arr[10] + this->arr[12] * m2.arr[11];
            m.arr[12] = this->arr[0] * m2.arr[12] + this->arr[4] * m2.arr[13] + this->arr[8] * m2.arr[14] + this->arr[12] * m2.arr[15];
            // Second row
            m.arr[1] = this->arr[1] * m2.arr[0] + this->arr[5] * m2.arr[1] + this->arr[9] * m2.arr[2] + this->arr[13] * m2.arr[3];
            m.arr[5] = this->arr[1] * m2.arr[4] + this->arr[5] * m2.arr[5] + this->arr[9] * m2.arr[6] + this->arr[13] * m2.arr[7];
            m.arr[9] = this->arr[1] * m2.arr[8] + this->arr[5] * m2.arr[9] + this->arr[9] * m2.arr[10] + this->arr[13] * m2.arr[11];
            m.arr[13] = this->arr[1] * m2.arr[12] + this->arr[5] * m2.arr[13] + this->arr[9] * m2.arr[14] + this->arr[13] * m2.arr[15];
            // Third row
            m.arr[2] = this->arr[2] * m2.arr[0] + this->arr[6] * m2.arr[1] + this->arr[10] * m2.arr[2] + this->arr[14] * m2.arr[3];
            m.arr[6] = this->arr[2] * m2.arr[4] + this->arr[6] * m2.arr[5] + this->arr[10] * m2.arr[6] + this->arr[14] * m2.arr[7];
            m.arr[10] = this->arr[2] * m2.arr[8] + this->arr[6] * m2.arr[9] + this->arr[10] * m2.arr[10] + this->arr[14] * m2.arr[11];
            m.arr[14] = this->arr[2] * m2.arr[12] + this->arr[6] * m2.arr[13] + this->arr[10] * m2.arr[14] + this->arr[14] * m2.arr[15];
            // Bottom row
            m.arr[3] = this->arr[3] * m2.arr[0] + this->arr[7] * m2.arr[1] + this->arr[11] * m2.arr[2] + this->arr[15] * m2.arr[3];
            m.arr[7] = this->arr[3] * m2.arr[4] + this->arr[7] * m2.arr[5] + this->arr[11] * m2.arr[6] + this->arr[15] * m2.arr[7];
            m.arr[11] = this->arr[3] * m2.arr[8] + this->arr[7] * m2.arr[9] + this->arr[11] * m2.arr[10] + this->arr[15] * m2.arr[11];
            m.arr[15] = this->arr[3] * m2.arr[12] + this->arr[7] * m2.arr[13] + this->arr[11] * m2.arr[14] + this->arr[15] * m2.arr[15];

            return m;
        }

        //! Do matrix times vector multiplication, v = mat * v1
        constexpr std::array<F, 4> operator* (const std::array<F, 4>& v1) const noexcept
        {
            std::array<F, 4> v;
            v[0] = this->arr[0] * v1[0] + this->arr[4] * v1[1] + this->arr[8] * v1[2] + this->arr[12] * v1[3];
            v[1] = this->arr[1] * v1[0] + this->arr[5] * v1[1] + this->arr[9] * v1[2] + this->arr[13] * v1[3];
            v[2] = this->arr[2] * v1[0] + this->arr[6] * v1[1] + this->arr[10] * v1[2] + this->arr[14] * v1[3];
            v[3] = this->arr[3] * v1[0] + this->arr[7] * v1[1] + this->arr[11] * v1[2] + this->arr[15] * v1[3];
            return v;
        }

        //! Do matrix times vector multiplication, v = mat * v1
        constexpr sm::vec<F, 4> operator* (const sm::vec<F, 4>& v1) const noexcept
        {
            sm::vec<F, 4> v;
            v[0] = this->arr[0] * v1.x() + this->arr[4] * v1.y() + this->arr[8] * v1.z() + this->arr[12] * v1.w();
            v[1] = this->arr[1] * v1.x() + this->arr[5] * v1.y() + this->arr[9] * v1.z() + this->arr[13] * v1.w();
            v[2] = this->arr[2] * v1.x() + this->arr[6] * v1.y() + this->arr[10] * v1.z() + this->arr[14] * v1.w();
            v[3] = this->arr[3] * v1.x() + this->arr[7] * v1.y() + this->arr[11] * v1.z() + this->arr[15] * v1.w();
            return v;
        }

        //! Do matrix times vector multiplication, v = mat * v1.
        constexpr sm::vec<F, 4> operator* (const sm::vec<F, 3>& v1) const noexcept
        {
            sm::vec<F, 4> v;
            v[0] = this->arr[0] * v1.x() + this->arr[4] * v1.y() + this->arr[8] * v1.z() + this->arr[12];
            v[1] = this->arr[1] * v1.x() + this->arr[5] * v1.y() + this->arr[9] * v1.z() + this->arr[13];
            v[2] = this->arr[2] * v1.x() + this->arr[6] * v1.y() + this->arr[10] * v1.z() + this->arr[14];
            v[3] = this->arr[3] * v1.x() + this->arr[7] * v1.y() + this->arr[11] * v1.z() + this->arr[15];
            return v;
        }

        //! *= operator for a scalar value.
        template <typename T=F> requires std::is_arithmetic_v<T>
        constexpr void operator*= (const T& f) noexcept
        {
            for (unsigned int i = 0; i<16; ++i) { this->arr[i] *= f; }
        }

        //! Equality operator. True if all elements match
        constexpr bool operator== (const mat<F>& rhs) const noexcept
        {
            unsigned int ndiff = 0;
            for (unsigned int i = 0; i < 16 && ndiff == 0; ++i) {
                ndiff += this->arr[i] == rhs.arr[i] ? 0 : 1;
            }
            return ndiff == 0;
        }

        //! Not equals
        constexpr bool operator!= (const mat<F>& rhs) const noexcept
        {
            unsigned int ndiff = 0;
            for (unsigned int i = 0; i < 16 && ndiff == 0; ++i) {
                ndiff += this->arr[i] == rhs.arr[i] ? 0 : 1;
            }
            return ndiff > 0;
        }

        //! Transpose this matrix
        constexpr void transpose_inplace() noexcept
        {
            std::array<F, 6> a;
            a[0] = this->arr[4];
            a[1] = this->arr[8];
            a[2] = this->arr[9];
            a[3] = this->arr[12];
            a[4] = this->arr[13];
            a[5] = this->arr[14];

            this->arr[4] = this->arr[1];
            this->arr[8] = this->arr[2];
            this->arr[9] = this->arr[6];
            this->arr[12] = this->arr[3];
            this->arr[13] = this->arr[7];
            this->arr[14] = this->arr[11];

            this->arr[1] = a[0];  // arr[4]
            this->arr[2] = a[1];  // arr[8]
            this->arr[3] = a[3];  // arr[12]
            this->arr[6] = a[2];  // arr[9]
            this->arr[7] = a[4];  // arr[13]
            this->arr[11] = a[5]; // arr[14]
        }

        //! Return the matrix transposed
        constexpr mat<F> transpose() const noexcept
        {
            mat<F> m = *this;
            std::array<F, 6> a;
            a[0] = this->arr[4];
            a[1] = this->arr[8];
            a[2] = this->arr[9];
            a[3] = this->arr[12];
            a[4] = this->arr[13];
            a[5] = this->arr[14];

            m[4] = this->arr[1];
            m[8] = this->arr[2];
            m[9] = this->arr[6];
            m[12] = this->arr[3];
            m[13] = this->arr[7];
            m[14] = this->arr[11];

            m[1] = a[0];  // arr[4]
            m[2] = a[1];  // arr[8]
            m[3] = a[3];  // arr[12]
            m[6] = a[2];  // arr[9]
            m[7] = a[4];  // arr[13]
            m[11] = a[5]; // arr[14]

            return m;
        }

        //! Transpose the matrix @cm, returning the transposed version.
        static constexpr std::array<F, 16> transpose (const std::array<F, 16>& cm) noexcept
        {
            std::array<F, 16> m;
            m[0] = cm[0];
            m[4] = cm[1];
            m[8] = cm[2];
            m[12] = cm[3];
            m[1] = cm[4];
            m[5] = cm[5];
            m[9] = cm[6];
            m[13] = cm[7];
            m[2] = cm[8];
            m[6] = cm[9];
            m[10] = cm[10];
            m[14] = cm[11];
            m[3] = cm[12];
            m[7] = cm[13];
            m[11] = cm[14];
            m[15] = cm[15];
            return m;
        }

        /*!
         * Make a (frustrum) perspective projection in this matrix
         *
         * @fovDeg Field of view, in degrees. Measured from the top of the field to
         * the bottom of the field (rather than from the left to the right).
         *
         * @aspect The field's aspect ratio. For a field which is wider than it is
         * high, this will be >1. That is, this is "the number of multiples of the
         * height that the width is"
         *
         * @zNear The near/projection plane.
         *
         * @zFar The far plane.
         */
        constexpr void perspective_inplace (F fovDeg, F aspect, F zNear, F zFar) noexcept
        {
            (*this) = sm::mat<F>::perspective (fovDeg, aspect, zNear, zFar);
        }

        /*!
         * Make a (frustrum) perspective projection
         *
         * @fovDeg Field of view, in degrees. Measured from the top of the field to
         * the bottom of the field (rather than from the left to the right).
         *
         * @aspect The field's aspect ratio. For a field which is wider than it is
         * high, this will be >1. That is, this is "the number of multiples of the
         * height that the width is"
         *
         * @zNear The near/projection plane.
         *
         * @zFar The far plane.
         *
         * \return the perspective projection matrix
         */
        static constexpr sm::mat<F> perspective (F fovDeg, F aspect, F zNear, F zFar) noexcept
        {
            sm::mat<F> m;

            // Bail out if the projection volume is zero-sized.
            if (zNear == zFar || aspect == F{0}) { return m; }

            F fovRad_ov2 = fovDeg * sm::mathconst<F>::pi_over_360; // fovDeg/2 converted to radians
            F sineFov = sm::cem::sin (fovRad_ov2);
            if (sineFov == F{0}) { return m; }
            F cotanFov = sm::cem::cos (fovRad_ov2) / sineFov;
            F clip = zFar - zNear;

            // Build perspective matrix
            m.arr.fill (F{0});
            m.arr[0] = cotanFov / aspect; // n/(width/2) = 2n/width, or generally 2n/r-l
            m.arr[5] = cotanFov;          // n/(height/2) = 2n/height, or generally 2n/t-b
            // For fully general frustrum not centered on the z axis, we would add these:
            //m.arr[8] = r+l/r-l
            //m.arr[9] = t+b/t-b
            m.arr[10] = -(zNear + zFar) / clip;
            m.arr[11] = F{-1};
            m.arr[14] = -(F{2} * zNear * zFar) / clip;

            return m;
        }

        /*!
         * Make an orthographic projection into this matrix
         *
         * \param rt Right-top coordinate. rt[0] is 'x' and thus the right and rt[1] ('y') is the top
         *
         * \param lb Left-bottom coordinate. lb[0] is 'x' and thus the left and lb[1] 'y' and is the bottom
         *
         * \param zFar The 'far' z coordinate of the canonical viewing volume
         *
         * \param zNear The 'near' z coordinate of the canonical viewing volume
         */
        constexpr void orthographic_inplace (const sm::vec<F, 2>& lb, const sm::vec<F, 2>& rt,
                                             const F zNear, const F zFar) noexcept
        {
            (*this) = sm::mat<F>::orthographic (lb, rt, zNear, zFar);
        }

        /*!
         * Make an orthographic projection, returning as mat
         *
         * \param rt Right-top coordinate. rt[0] is 'x' and thus the right and rt[1] ('y') is the top
         *
         * \param lb Left-bottom coordinate. lb[0] is 'x' and thus the left and lb[1] 'y' and is the bottom
         *
         * \param zFar The 'far' z coordinate of the canonical viewing volume
         *
         * \param zNear The 'near' z coordinate of the canonical viewing volume
         */
        static constexpr sm::mat<F> orthographic (const sm::vec<F, 2>& lb, const sm::vec<F, 2>& rt,
                                                    const F zNear, const F zFar) noexcept
        {
            sm::mat<F> m;

            if (zNear == zFar) { return m; }

            // Build orthographic matrix
            m.arr.fill (F{0});
            m.arr[0] = F{2} / (rt[0] - lb[0]);              //      2/(r-l)
            m.arr[5] = F{2} / (rt[1] - lb[1]);              //      2/(t-b)
            m.arr[10] = F{-2} / (zFar - zNear);             //     -2/(f-n)
            m.arr[12] = -(rt[0] + lb[0]) / (rt[0] - lb[0]); // -(r+l)/(r-l)
            m.arr[13] = -(rt[1] + lb[1]) / (rt[1] - lb[1]); // -(t+b)/(t-b)
            m.arr[14] = -(zFar + zNear) / (zFar - zNear);   // -(f+n)/(f-n)
            m.arr[15] = F{1};

            return m;
        }

        //! Overload the stream output operator
        friend std::ostream& operator<< <F> (std::ostream& os, const mat<F>& tm);
    };

    template <typename F>
    std::ostream& operator<< (std::ostream& os, const mat<F>& tm)
    {
        os << tm.str();
        return os;
    }

} // namespace sm
