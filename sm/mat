// -*- C++ -*-
/*!
 * This file is part of sebsjames/maths, a library of maths code for modern C++
 *
 * See https://github.com/sebsjames/maths
 *
 * \file
 *
 * A matrix class
 *
 * \author Seb James
 * \date 2019
 * Initial code author, maintenance.
 *
 * \author Alex Blenkinsop
 * \date 2025
 * Improvements to methods that specify rotations and translations
 */
#pragma once

#include <cstdint>
#include <array>
#include <string>
#include <sstream>
#include <iostream>
#include <type_traits>
#include <initializer_list>
#include <complex>

#include <sm/mathconst>
#include <sm/quaternion>
#include <sm/vec>
#include <sm/constexpr_math>
// #include <sm/polysolve>

namespace sm
{
    // Forward declare class and stream operator
    template <typename F, uint32_t Nr, uint32_t Nc = Nr> requires std::is_floating_point_v<F> struct mat;
    template <typename F, uint32_t Nr, uint32_t Nc = Nr> std::ostream& operator<< (std::ostream&, const mat<F, Nr, Nc>&);

    /*!
     * A more general purpose mat class.
     *
     * \templateparam F The arithmetic? floating point? type in which to store the mat44's data.
     */
    template <typename F, uint32_t Nr, uint32_t Nc> requires std::is_floating_point_v<F>
    struct mat
    {
        //! Default constructor
        constexpr mat() noexcept
        {
            if constexpr (Nr == Nc) { this->set_identity(); }
            else { this->set_zero(); }
        }
        //! Construct 4x4 matrix from a 3x3 rotation matrix
        template<typename Fy = F> requires (Nr == 4) && (Nc == 4)
        constexpr mat (const sm::mat<Fy, 3>& other) noexcept
        {
            this->arr[0] = other[0];
            this->arr[1] = other[1];
            this->arr[2] = other[2];
            this->arr[3] = F{0};

            this->arr[4] = other[3];
            this->arr[5] = other[4];
            this->arr[6] = other[5];
            this->arr[7] = F{0};

            this->arr[8] = other[6];
            this->arr[9] = other[7];
            this->arr[10] = other[8];
            this->arr[11] = F{0};

            this->arr[12] = F{0};
            this->arr[13] = F{0};
            this->arr[14] = F{0};
            this->arr[15] = F{1};
        }
        //! Initializer list construction
        constexpr mat (std::initializer_list<F> other) noexcept
        {
            uint32_t i = 0u;
            for (i = 0u; i < Nr * Nc; ++i) { this->arr[i] = F{0}; }
            i = 0u;
            for (F elem : other) {
                this->arr[i++] = elem;
                if (i == Nr * Nc) { break; } // only first Nr * Nc elements can be copied
            }
        }
        //! Construct with an array
        constexpr mat (const std::array<F, Nr * Nc>& other) noexcept { this->arr = other; }
        //! User-declared copy constructor
        constexpr mat (const mat<F, Nr, Nc>& other) noexcept : arr(other.arr) {}
        //! User-declared copy assignment constructor
        constexpr mat<F, Nr, Nc>& operator= (const mat<F, Nr, Nc>& other) noexcept
        {
            arr = other.arr;
            return *this;
        }
        //! Explicitly defaulted  move constructor
        mat (mat<F, Nr, Nc>&& other) noexcept = default;
        //! Explicitly defaulted move assignment constructor
        mat<F, Nr, Nc>& operator= (mat<F, Nr, Nc>&& other) noexcept = default;

        /*!
         * The transformation matrix data, arranged in column major format to be OpenGL
         * friendly.
         */
        alignas(std::array<F, Nr * Nc>) std::array<F, Nr * Nc> arr;

        //! Return a string representation of the passed-in array (assumed column major and containing Nc columns)
        static std::string str (const std::array<F, Nr * Nc>& _arr) noexcept
        {
            std::stringstream ss;
            ss <<"[ ";
            for (uint32_t r = 0; r < Nr; ++r) {
                if (r == 0) {
                    ss << " ";
                } else {
                    ss << "   ";
                }
                for (uint32_t c = 0; c < Nc; ++c) {
                    ss << _arr[r + (c * Nr)];
                    if (c != Nc - 1) {
                        ss << ", ";
                    } else {
                        if (r != Nr - 1) { ss << " \n"; }
                    }
                }
            }
            ss << "  ]\n";
            return ss.str();
        }

        //! Return a string representation of the matrix
        std::string str() const noexcept { return this->str (this->arr); }

        //! set_identity is self-explanatory
        constexpr void set_identity() noexcept
        {
            if constexpr (Nr != Nc) {
                []<bool flag = false>() { static_assert(flag, "this function applies to square matrices"); }();
            }
            this->arr.fill (F{0});
            for (uint32_t i = 0; i < Nr * Nc; i += Nr + 1) { this->arr[i] = F{1}; }
        }

        constexpr void set_zero() noexcept { this->arr.fill (F{0}); }

        //! Return the identity matrix
        static constexpr mat<F, Nr, Nc> identity() noexcept { return sm::mat<F, Nr, Nc>{}; }

        //! Set *this from a transform matrix to transform a coordinate into the given coordinate basis set
        constexpr void frombasis_inplace (const sm::vec<F> bx, const sm::vec<F> by, const sm::vec<F> bz)
        {
            if constexpr (Nr != 4 || Nr != Nc) { []<bool flag = false>() { static_assert(flag, "valid only for 4x4 matrices"); }(); }
            (*this) = sm::mat<F, 4>::frombasis (bx, by, bz);
        }

        //! Create a transform matrix to transform a coordinate into the given coordinate basis set
        static constexpr mat<F, 4> frombasis (const sm::vec<F> bx, const sm::vec<F> by, const sm::vec<F> bz)
        {
            if constexpr (Nr != 4 || Nr != Nc) { []<bool flag = false>() { static_assert(flag, "valid only for 4x4 matrices"); }(); }
            sm::mat<F, 4> m;

            m[0] = bx.x();
            m[1] = bx.y();
            m[2] = bx.z();
            m[3] = F{0};

            m[4] = by.x();
            m[5] = by.y();
            m[6] = by.z();
            m[7] = F{0};

            m[8] = bz.x();
            m[9] = bz.y();
            m[10] = bz.z();
            m[11] = F{0};

            m[12] = F{0};
            m[13] = F{0};
            m[14] = F{0};
            m[15] = F{1};

            return m;
        }

        //! Access elements of the matrix (returns ref, so not const)
        constexpr F& operator[] (const uint32_t idx) noexcept { return this->arr[idx]; }

        //! Access elements of the matrix with const promise
        constexpr F operator[] (const uint32_t idx) const noexcept { return this->arr[idx]; }

        //! Access a given row of the matrix
        constexpr sm::vec<F, Nc> row (uint32_t idx) const noexcept
        {
            sm::vec<F, Nc> r = {};
            if (idx >= Nc) { return r; }
            for (uint32_t i = 0; i < Nc; ++i) { r[i] = this->arr[idx * Nr * i]; }
            return r;
        }

        //! Access a given column of the matrix
        constexpr sm::vec<F, Nr> col (uint32_t idx) const noexcept
        {
            sm::vec<F, Nr> c = {};
            if (idx >= Nr) { return c; }
            idx *= Nr;
            for (uint32_t i = 0; i < Nr; ++i) { c[i] = this->arr[idx++]; }
            return c;
        }

        //! Apply pre-translation specified by vector @dv as this = m * this (pre-multiply)
        template<typename T, std::size_t N = 3> requires std::is_arithmetic_v<T> && (N == 3 || N == 4) && (Nr == 4) && (Nc == 4)
        constexpr void pretranslate (const sm::vec<T, N>& dv) noexcept
        {
            this->arr[12] += dv[0];
            this->arr[13] += dv[1];
            this->arr[14] += dv[2];
        }

        //! Apply pre-translation specified by vector @dv provided as array of three coordinates as
        //! this = m * this (pre-multiply)
        template<typename T, std::size_t N = 3> requires std::is_arithmetic_v<T> && (N == 3 || N == 4) && (Nr == 4) && (Nc == 4)
        constexpr void pretranslate (const std::array<T, N>& dv) noexcept
        {
            this->arr[12] += dv[0];
            this->arr[13] += dv[1];
            this->arr[14] += dv[2];
        }

        //! Apply pre-translation specified by coordinates @dx, @dy and @dz as this = m * this
        //! (pre-multiply)
        template<typename T> requires std::is_arithmetic_v<T> && (Nr == 4) && (Nc == 4)
        constexpr void pretranslate (const T& dx, const T& dy, const T& dz) noexcept
        {
            this->arr[12] += dx;
            this->arr[13] += dy;
            this->arr[14] += dz;
        }

        //! Apply translation specified by vector @dv as this = this * m (post-multiply)
        template<typename T, std::size_t N = 3> requires std::is_arithmetic_v<T> && (N == 3 || N == 4) && (Nr == 4) && (Nc == 4)
        constexpr void translate (const sm::vec<T, N>& dv) noexcept
        {
            mat<T, Nr, Nc> transmat;
            transmat[12] = dv[0];
            transmat[13] = dv[1];
            transmat[14] = dv[2];

            *this *= transmat;
        }

        //! Apply translation specified by vector @dv provided as array of three coordinates as this
        //! = this * m (post-multiply)
        template<typename T, std::size_t N = 3> requires std::is_arithmetic_v<T> && (N == 3 || N == 4) && (Nr == 4) && (Nc == 4)
        constexpr void translate (const std::array<T, N>& dv) noexcept
        {
            mat<T, Nr, Nc> transmat;
            transmat[12] = dv[0];
            transmat[13] = dv[1];
            transmat[14] = dv[2];

            *this *= transmat;
        }

        //! Apply translation specified by coordinates @dx, @dy and @dz. as this = this * m
        //! (post-multiply)
        template<typename T> requires std::is_arithmetic_v<T> && (Nr == 4) && (Nc == 4)
        constexpr void translate (const T& dx, const T& dy, const T& dz) noexcept
        {
            mat<T, Nr, Nc> transmat;
            transmat[12] = dx;
            transmat[13] = dy;
            transmat[14] = dz;
            *this *= transmat;
        }

        //! Scaling transformation by individual dims
        template<typename T> requires std::is_arithmetic_v<T> && (Nr == 4) && (Nc == 4)
        constexpr void scale (const T& scl_x, const T& scl_y, const T& scl_z) noexcept
        {
            // This is the rotation matrix multiplied by a diagonalized matrix made from scl_x/y/z
            this->arr[0] *= scl_x;
            this->arr[1] *= scl_x;
            this->arr[2] *= scl_x;

            this->arr[4] *= scl_y;
            this->arr[5] *= scl_y;
            this->arr[6] *= scl_y;

            this->arr[8] *= scl_z;
            this->arr[9] *= scl_z;
            this->arr[10] *= scl_z;
        }

        //! Scaling transformation by vector. this = this * m (post-multiplication)
        template<typename T, std::size_t N = 3> requires std::is_arithmetic_v<T> && (N == 3 || N == 4) && (Nr == 4) && (Nc == 4)
        constexpr void scale (const sm::vec<T, N>& scl) noexcept
        {
            this->arr[0] *= scl[0];
            this->arr[1] *= scl[0];
            this->arr[2] *= scl[0];

            this->arr[4] *= scl[1];
            this->arr[5] *= scl[1];
            this->arr[6] *= scl[1];

            this->arr[8] *= scl[2];
            this->arr[9] *= scl[2];
            this->arr[10] *= scl[2];
        }

        //! Scaling transformation by array. this = this * m (post-multiplication)
        template<typename T, std::size_t N = 3> requires std::is_arithmetic_v<T> && (N == 3 || N == 4) && (Nr == 4) && (Nc == 4)
        constexpr void scale (const std::array<T, N>& scl) noexcept
        {
            this->arr[0] *= scl[0];
            this->arr[1] *= scl[0];
            this->arr[2] *= scl[0];

            this->arr[4] *= scl[1];
            this->arr[5] *= scl[1];
            this->arr[6] *= scl[1];

            this->arr[8] *= scl[2];
            this->arr[9] *= scl[2];
            this->arr[10] *= scl[2];
        }

        //! Scaling transformation by scalar. this = this * m (post-multiplication)
        template<typename T> requires std::is_arithmetic_v<T> && (Nr == 4) && (Nc == 4)
        constexpr void scale (const T& scl) noexcept
        {
            this->arr[0] *= scl;
            this->arr[1] *= scl;
            this->arr[2] *= scl;

            this->arr[4] *= scl;
            this->arr[5] *= scl;
            this->arr[6] *= scl;

            this->arr[8] *= scl;
            this->arr[9] *= scl;
            this->arr[10] *= scl;
        }

        //! Compute determinant for 3x3 or 4x4 matrix @cm
        static constexpr F determinant (const std::array<F, Nr * Nc>& cm) noexcept
        {
            if constexpr (Nr != Nc) {
                []<bool flag = false>() { static_assert(flag, "valid only for square matrices"); }();
            }

            F det = F{0};

            if constexpr (Nr == 2) {
                det = ((cm[0] * cm[3]) - (cm[1] * cm[2]));

            } else if constexpr (Nr == 3) {
                det = (cm[0] * cm[4] * cm[8])
                + (cm[3] * cm[7] * cm[2])
                + (cm[6] * cm[1] * cm[5])
                - (cm[6] * cm[4] * cm[2])
                - (cm[0] * cm[7] * cm[5])
                - (cm[3] * cm[1] * cm[8]);

            } else if constexpr (Nr == 4) {
                // Configure the 3x3 matrices that have to be evaluated to get the 4x4 det.
                std::array<F, 9> cm33;

                // First 3x3 matrix
                cm33[0] = cm[5];
                cm33[1] = cm[6];
                cm33[2] = cm[7];
                cm33[3] = cm[9];
                cm33[4] = cm[10];
                cm33[5] = cm[11];
                cm33[6] = cm[13];
                cm33[7] = cm[14];
                cm33[8] = cm[15];

                det = cm[0] * mat<F, 3>::determinant (cm33);

                // Second 3x3
                cm33[0] = cm[1];
                cm33[1] = cm[2];
                cm33[2] = cm[3];
                cm33[3] = cm[9];
                cm33[4] = cm[10];
                cm33[5] = cm[11];
                cm33[6] = cm[13];
                cm33[7] = cm[14];
                cm33[8] = cm[15];

                det -= cm[4] * mat<F, 3>::determinant (cm33);

                // Third 3x3
                cm33[0] = cm[1];
                cm33[1] = cm[2];
                cm33[2] = cm[3];
                cm33[3] = cm[5];
                cm33[4] = cm[6];
                cm33[5] = cm[7];
                cm33[6] = cm[13];
                cm33[7] = cm[14];
                cm33[8] = cm[15];

                det += cm[8] * mat<F, 3>::determinant (cm33);

                // Final 3x3
                cm33[0] = cm[1];
                cm33[1] = cm[2];
                cm33[2] = cm[3];
                cm33[3] = cm[5];
                cm33[4] = cm[6];
                cm33[5] = cm[7];
                cm33[6] = cm[9];
                cm33[7] = cm[10];
                cm33[8] = cm[11];

                det -= cm[12] * mat<F, 3>::determinant (cm33);

            } else {
                []<bool flag = false>() { static_assert(flag, "implemented only for 2x2, 3x3, 4x4"); }();
            }

            return det;
        }

        //! Compute determinant for this->arr
        constexpr F determinant() const noexcept
        {
            if constexpr (Nr != Nc) { []<bool flag = false>() { static_assert(flag, "valid only for square matrices"); }(); }
            return mat<F, Nr, Nc>::determinant (this->arr);
        }

        /*!
         * The adjugate is the transpose of the cofactor matrix. Recipe:
         * 1. Get the cofactor matrix (with this->cofactor())
         * 2. Obtain the adjugate matrix by transposing the cofactor matrix
         */
        constexpr std::array<F, Nr * Nc> adjugate() const noexcept
        {
            std::array<F, Nr * Nc> adj = {};
            if constexpr (Nr == Nc && Nr == 2) {
                // Simple recipe for 2x2:
                adj = { this->arr[3], -this->arr[1], -this->arr[2], this->arr[0] };
            } else {
                adj = mat<F, Nr, Nc>::transpose (this->cofactor());
            }
            return adj;
        }

        /*!
         * Compute the cofactor matrix of this->arr. Recipe:
         * 1. Create matrix of minors
         * 2. Multiply matrix of minors by a checkerboard pattern to give the cofactor matrix
         */
        constexpr std::array<F, Nr * Nc> cofactor() const noexcept
        {
            if constexpr (Nr != Nc) { []<bool flag = false>() { static_assert(flag, "valid only for square matrices"); }(); }

            std::array<F, Nr * Nc> cofac;

            if constexpr (Nr == 3) {

                // Keep to column-major format for all matrices. The elements of the matrix
                // of minors is found, but the cofactor matrix is populated, applying the
                // alternating pattern of +/- as we go.

                // 0.
                std::array<F, 4> minorElem;
                minorElem[0] = this->arr[4];
                minorElem[1] = this->arr[5];
                minorElem[2] = this->arr[7];
                minorElem[3] = this->arr[8];
                cofac[0] = mat<F, 2>::determinant (minorElem);

                // 3. Next minor elem matrix has only 2 elements changed
                minorElem[0] = this->arr[1];
                minorElem[1] = this->arr[2];
                cofac[3] = -mat<F, 2>::determinant (minorElem);

                // 6.
                minorElem[2] = this->arr[4];
                minorElem[3] = this->arr[5];
                cofac[6] = mat<F, 2>::determinant (minorElem);

                // 1.
                minorElem[0] = this->arr[3];
                minorElem[1] = this->arr[5];
                minorElem[2] = this->arr[6];
                minorElem[3] = this->arr[8];
                cofac[1] = -mat<F, 2>::determinant (minorElem);

                // 4.
                minorElem[0] = this->arr[0];
                minorElem[1] = this->arr[2];
                cofac[4] = mat<F, 2>::determinant (minorElem);

                // 7.
                minorElem[2] = this->arr[3];
                minorElem[3] = this->arr[5];
                cofac[7] = -mat<F, 2>::determinant (minorElem);

                // 2.
                minorElem[0] = this->arr[3];
                minorElem[1] = this->arr[4];
                minorElem[2] = this->arr[6];
                minorElem[3] = this->arr[7];
                cofac[2] = mat<F, 2>::determinant (minorElem);

                // 5.
                minorElem[0] = this->arr[0];
                minorElem[1] = this->arr[1];
                cofac[5] = -mat<F, 2>::determinant (minorElem);

                // 8.
                minorElem[2] = this->arr[3];
                minorElem[3] = this->arr[4];
                cofac[8] = mat<F, 2>::determinant (minorElem);

            } else if constexpr (Nr == 4) {

                // Keep to column-major format for all matrices. The elements of the matrix
                // of minors is found, but the cofactor matrix is populated, applying the
                // alternating pattern of +/- as we go.

                // 0.
                std::array<F, 9> minorElem;
                minorElem[0] = this->arr[5];
                minorElem[3] = this->arr[9];
                minorElem[6] = this->arr[13];

                minorElem[1] = this->arr[6];
                minorElem[4] = this->arr[10];
                minorElem[7] = this->arr[14];

                minorElem[2] = this->arr[7];
                minorElem[5] = this->arr[11];
                minorElem[8] = this->arr[15];

                cofac[0] = mat<F, 3>::determinant (minorElem);

                // 1. Next minor elem matrix has only 3 elements changed
                minorElem[0] = this->arr[4];
                minorElem[3] = this->arr[8];
                minorElem[6] = this->arr[12];
                cofac[1] = -mat<F, 3>::determinant (minorElem);

                // 2
                minorElem[1] = this->arr[5];
                minorElem[4] = this->arr[9];
                minorElem[7] = this->arr[13];
                cofac[2] = mat<F, 3>::determinant (minorElem);

                // 3
                minorElem[2] = this->arr[6];
                minorElem[5] = this->arr[10];
                minorElem[8] = this->arr[14];
                cofac[3] = -mat<F, 3>::determinant (minorElem);

                // 4.
                minorElem[0] = this->arr[1];
                minorElem[3] = this->arr[9];
                minorElem[6] = this->arr[13];

                minorElem[1] = this->arr[2];
                minorElem[4] = this->arr[10];
                minorElem[7] = this->arr[14];

                minorElem[2] = this->arr[3];
                minorElem[5] = this->arr[11];
                minorElem[8] = this->arr[15];

                cofac[4] = -mat<F, 3>::determinant (minorElem);

                // 5.
                minorElem[0] = this->arr[0];
                minorElem[3] = this->arr[8];
                minorElem[6] = this->arr[12];
                cofac[5] = mat<F, 3>::determinant (minorElem);

                // 6.
                minorElem[1] = this->arr[1];
                minorElem[4] = this->arr[9];
                minorElem[7] = this->arr[13];
                cofac[6] = -mat<F, 3>::determinant (minorElem);

                // 7.
                minorElem[2] = this->arr[2];
                minorElem[5] = this->arr[10];
                minorElem[8] = this->arr[14];
                cofac[7] = mat<F, 3>::determinant (minorElem);

                // 8.
                minorElem[0] = this->arr[1];
                minorElem[3] = this->arr[5];
                minorElem[6] = this->arr[13];

                minorElem[1] = this->arr[2];
                minorElem[4] = this->arr[6];
                minorElem[7] = this->arr[14];

                minorElem[2] = this->arr[3];
                minorElem[5] = this->arr[7];
                minorElem[8] = this->arr[15];

                cofac[8] = mat<F, 3>::determinant (minorElem);

                // 9.
                minorElem[0] = this->arr[0];
                minorElem[3] = this->arr[4];
                minorElem[6] = this->arr[12];
                cofac[9] = -mat<F, 3>::determinant (minorElem);

                // 10.
                minorElem[1] = this->arr[1];
                minorElem[4] = this->arr[5];
                minorElem[7] = this->arr[13];
                cofac[10] = mat<F, 3>::determinant (minorElem);

                // 11.
                minorElem[2] = this->arr[2];
                minorElem[5] = this->arr[6];
                minorElem[8] = this->arr[14];
                cofac[11] = -mat<F, 3>::determinant (minorElem);

                // 12.
                minorElem[0] = this->arr[1];
                minorElem[3] = this->arr[5];
                minorElem[6] = this->arr[9];

                minorElem[1] = this->arr[2];
                minorElem[4] = this->arr[6];
                minorElem[7] = this->arr[10];

                minorElem[2] = this->arr[3];
                minorElem[5] = this->arr[7];
                minorElem[8] = this->arr[11];

                cofac[12] = -mat<F, 3>::determinant (minorElem);

                // 13.
                minorElem[0] = this->arr[0];
                minorElem[3] = this->arr[4];
                minorElem[6] = this->arr[8];
                cofac[13] = mat<F, 3>::determinant (minorElem);

                // 14.
                minorElem[1] = this->arr[1];
                minorElem[4] = this->arr[5];
                minorElem[7] = this->arr[9];
                cofac[14] = -mat<F, 3>::determinant (minorElem);

                // 15.
                minorElem[2] = this->arr[2];
                minorElem[5] = this->arr[6];
                minorElem[8] = this->arr[10];
                cofac[15] = mat<F, 3>::determinant (minorElem);

            } else {
                []<bool flag = false>() { static_assert(flag, "cofactor provided only for 3x3 and 4x4 matrices"); }();
            }

            return cofac;
        }

        //! Compute the trace of the matrix (the sum of the diagonal elements)
        constexpr F trace() const noexcept
        {
            if constexpr (Nr != Nc) { []<bool flag = false>() { static_assert(flag, "valid only for square matrices"); }(); }

            F tr = F{0};
            for (uint32_t i = 0; i < Nr * Nc; i += Nr + 1) {
                tr += this->arr[i];
            }
            return tr;
        }

        /*!
         * Return the inverse matrix.
         *
         * Implement inversion using determinant method. inverse is (1/det) x adjugate
         * matrix.
         *
         * 1. Compute determinant of this->arr (if 0, then there's no inverse)
         * 2. Obtain the adjugate matrix
         * 3. Get the inverse by multiplying 1/determinant by the adjugate
         */
        constexpr mat<F, Nr, Nc> inverse() const noexcept
        {
            if constexpr (Nr != Nc) { []<bool flag = false>() { static_assert(flag, "valid only for square matrices"); }(); }

            F det = this->determinant();
            mat<F, Nr, Nc> m;
            if (det == F{0}) {
                // The transform matrix has no inverse (determinant is 0)
                m.arr.fill (F{0});
            } else {
                m.arr = this->adjugate();
                m *= (F{1} / det);
            }
            return m;
        }

        /*!
         * Turn the matrix into its inverse.
         *
         * Implement inversion using determinant method. inverse is (1/det) x adjugate
         * matrix.
         *
         * 1. Compute determinant of this->arr (if 0, then there's no inverse)
         * 2. Obtain the adjugate matrix
         * 3. Get the inverse by multiplying 1/determinant by the adjugate
         */
        constexpr void inverse_inplace() noexcept
        {
            if constexpr (Nr != Nc) { []<bool flag = false>() { static_assert(flag, "valid only for square matrices"); }(); }

            F det = this->determinant();
            if (det == F{0}) {
                // The transform matrix has no inverse (determinant is 0)
                this->arr.fill (F{0});
            } else {
                this->arr = this->adjugate();
                *this *= (F{1} / det);
            }
        }

#if 0
        /*!
         * Compute the eigenvalues of this 4x4 matrix.
         * Returns a vector of 4 complex eigenvalues.
         *
         * Uses the Faddeev-LeVerrier algorithm to compute the characteristic
         * polynomial det(A - lambda*I) = 0, then solves for roots using polysolve.
         */
        sm::vec<std::complex<F>, 4> eigenvalues() const noexcept
        {
            if constexpr (Nr != Nc || Nr != 4) { []<bool flag = false>() { static_assert(flag, "valid only for 4x4 matrices"); }(); }

            // Use Faddeev-LeVerrier algorithm to get characteristic polynomial
            sm::vvec<F> coeffs(5, F{0});
            coeffs[4] = F{1};  // Leading coefficient

            sm::mat<F> M;

            for (int k = 1; k <= 4; ++k) {
                M = (*this) * M;  // M_k = A * M_{k-1}, where M_0 = I
                F trace = M.trace();
                coeffs[4 - k] = -trace / F(k);

                if (k < 4) {
                    // M = M_k + c_{n-k} * I
                    M[0] += coeffs[4 - k];
                    M[5] += coeffs[4 - k];
                    M[10] += coeffs[4 - k];
                    M[15] += coeffs[4 - k];
                }
            }

            sm::vvec<std::complex<F>> roots_vec = sm::polysolve::solve<F> (coeffs);

            // Convert from sm::vvec to sm::vec for return type
            sm::vec<std::complex<F>, 4> roots;
            roots[0] = roots_vec[0];
            roots[1] = roots_vec[1];
            roots[2] = roots_vec[2];
            roots[3] = roots_vec[3];

            return roots;
        }

        /*!
         * Find an eigenvector for a given eigenvalue.
         * Returns a normalized eigenvector as a complex vector.
         */
        sm::vec<std::complex<F>, 4> eigenvector (const std::complex<F>& lambda) const noexcept
        {
            constexpr F my_epsilon = F{1e-14};

            // Form (A - lambda * I)
            std::array<std::complex<F>, 16> Aarrinus_lambda = {};
            for (int i = 0; i < 16; ++i) {
                Aarrinus_lambda[i] = std::complex<F>{ this->arr[i], F{0} };
            }
            Aarrinus_lambda[0] -= lambda;
            Aarrinus_lambda[5] -= lambda;
            Aarrinus_lambda[10] -= lambda;
            Aarrinus_lambda[15] -= lambda;

            sm::vec<std::complex<F>, 4> v = {};

            // Simplified null space finder: use last component as free variable
            v[3] = std::complex<F>{ F{1}, F{0} };

            // Back substitute (simplified approach)
            if (std::abs (Aarrinus_lambda[10]) > my_epsilon) {
                v[2] = -Aarrinus_lambda[14] / Aarrinus_lambda[10];
            } else {
                v[2] = std::complex<F>{ F{0}, F{0} };
            }

            if (std::abs (Aarrinus_lambda[5]) > my_epsilon) {
                v[1] = -(Aarrinus_lambda[9] * v[2] + Aarrinus_lambda[13]) / Aarrinus_lambda[5];
            } else {
                v[1] = std::complex<F>{ F{0}, F{0} };
            }

            if (std::abs (Aarrinus_lambda[0]) > my_epsilon) {
                v[0] = -(Aarrinus_lambda[4] * v[1] + Aarrinus_lambda[8] * v[2] + Aarrinus_lambda[12]) / Aarrinus_lambda[0];
            } else {
                v[0] = std::complex<F>{ F{1}, F{0} };
            }

            // Normalize
            F norm = std::sqrt (std::norm (v[0]) + std::norm (v[1]) + std::norm (v[2]) + std::norm (v[3]));
            if (norm > my_epsilon) { v /= norm; }

            return v;
        }

        /*!
         * Compute both eigenvalues and their corresponding eigenvectors.
         * Returns a vector of 4 pairs, each containing an eigenvalue and its eigenvector.
         */
        struct eigenpair
        {
            std::complex<F> eigenvalue = {};
            sm::vec<std::complex<F>, 4> eigenvector = {};
        };

        sm::vec<eigenpair, 4> eigenpairs() const noexcept
        {
            sm::vec<eigenpair, 4> pairs = {};
            sm::vec<std::complex<F>, 4> lambdas = this->eigenvalues();

            pairs[0].eigenvalue = lambdas[0];
            pairs[0].eigenvector = this->eigenvector (lambdas[0]);

            pairs[1].eigenvalue = lambdas[1];
            pairs[1].eigenvector = this->eigenvector (lambdas[1]);

            pairs[2].eigenvalue = lambdas[2];
            pairs[2].eigenvector = this->eigenvector (lambdas[2]);

            pairs[3].eigenvalue = lambdas[3];
            pairs[3].eigenvector = this->eigenvector (lambdas[3]);

            return pairs;
        }
#endif
        template <typename T> requires std::is_arithmetic_v<T> && (Nr == 3) && (Nc == 3)
        static constexpr mat<F, 3> reflection (const sm::vec<T, 3>& n) noexcept
        {
            sm::mat<F, 3> r;
            // Reflection matrix = I - 2 * N * N^T
            r[0] = F{1} - n[0] * n[0] * F{2};
            r[1] =        n[1] * n[0] * F{2};
            r[2] =        n[2] * n[0] * F{2};

            r[3] =        n[0] * n[1] * F{2};
            r[4] = F{1} - n[1] * n[1] * F{2};
            r[5] =        n[2] * n[1] * F{2};

            r[6] =        n[0] * n[2] * F{2};
            r[7] =        n[1] * n[2] * F{2};
            r[8] = F{1} - n[2] * n[2] * F{2};

            return r;
        }

        // Set this mat up as a reflection transformation. Any existing transformation in the mat will be lost.
        template <typename T> requires std::is_arithmetic_v<T> && (Nr == 4) && (Nc == 4)
        static constexpr mat<F, Nr> reflection (const sm::vec<T, 3>& p, const sm::vec<T, 3> n) noexcept
        {
            // Order of operations: Translate -p (so that we reflect about 0), reflect about 0, untranslate.
            sm::mat<F, Nr> tr1;
            tr1.translate (-p);
            sm::mat<F, Nr> refl (sm::mat<F, 3>::reflection (n));
            sm::mat<F, Nr> tr2;
            tr2.translate (p);
            return /* tr1.inverse() or tr2 */ tr2 * refl * tr1;
        }

        /*!
         * Place a pure rotation q (with no translation) into a mat<F> and return it.
         *
         * This algorithm was obtained from:
         * http://www.j3d.org/matrix_faq/matrfaq_latest.html#Q54 (but was it transposed?
         * seems so. See also https://www.songho.ca/opengl/gl_quaternion.html#overview
         * and https://danceswithcode.net/engineeringnotes/quaternions/quaternions.html)
         */
        template <typename T> requires std::is_arithmetic_v<T> && (Nr == 4) && (Nc == 4)
        static constexpr mat<F, Nr> pure_rotation (const sm::quaternion<T>& q) noexcept
        {
            const F qx = static_cast<F>(q.x);
            const F qy = static_cast<F>(q.y);
            const F qz = static_cast<F>(q.z);
            const F qw = static_cast<F>(q.w);
            const F f2x = qx * F{2};
            const F f2y = qy * F{2};
            const F f2z = qz * F{2};
            const F f2xw = f2x * qw;
            const F f2yw = f2y * qw;
            const F f2zw = f2z * qw;
            const F f2xx = f2x * qx;
            const F f2xy = f2x * qy;
            const F f2xz = f2x * qz;
            const F f2yy = f2y * qy;
            const F f2yz = f2y * qz;
            const F f2zz = f2z * qz;

            mat<F, Nr> m;
            m[0]  = F{1} - (f2yy + f2zz);
            m[1]  =         f2xy + f2zw;
            m[2]  =         f2xz - f2yw;
            m[3]  = F{0};
            m[4]  =         f2xy - f2zw;
            m[5]  = F{1} - (f2xx + f2zz);
            m[6]  =         f2yz + f2xw;
            m[7]  = F{0};
            m[8]  =         f2xz + f2yw;
            m[9]  =         f2yz - f2xw;
            m[10] = F{1} - (f2xx + f2yy);
            m[11] = F{0};
            m[12] = F{0};
            m[13] = F{0};
            m[14] = F{0};
            m[15] = F{1};

            return m;
        }

        //! Apply the rotation q to this as a pre-multiplication: this = R * this
        template <typename T> requires std::is_arithmetic_v<T> && (Nr == 4) && (Nc == 4)
        constexpr void prerotate (const sm::quaternion<T>& q) noexcept { *this = this->pure_rotation (q) * *this; }

        /*!
         * Pre-rotate an angle theta radians about axis (specified as std::array). By default, axis
         * is not required to be normalized because quaternion::rotate will do this.
         *
         * Result is this = R * this  (rotation pre-multiplies)
         *
         * \tparam renorm If true, renormalize axis to length 1, if false, assume axis has already
         * been renormalized
         *
         * \tparam T type for operations, usually compiler-detected from axis and theta
         *
         * \tparam N Number of elements in the axis vector, compiler-detected from axis. Allows
         * passing of 3D and (3+1)D vectors
         */
        template <bool renorm = true, typename T = F, std::size_t N = 3> requires std::is_arithmetic_v<T> && (N == 3 || N == 4) && (Nr == 4) && (Nc == 4)
        constexpr void prerotate (const std::array<T, N>& axis, const T& theta) noexcept
        {
            sm::quaternion<T> q;
            q.template rotate<std::array<T, N>, renorm> (axis, theta);
            this->prerotate<T> (q);
        }

        /*!
         * Pre-rotate an angle theta radians about axis (specified as sm::vec). By default, axis is
         * not required to be normalized because quaternion::rotate will do this.
         *
         * Result is this = R * this  (rotation pre-multiplies)
         *
         * \tparam renorm If true, renormalize axis to length 1, if false, assume axis has already
         * been renormalized
         *
         * \tparam T type for operations, usually compiler-detected from axis and theta
         *
         * \tparam N Number of elements in the axis vector, compiler-detected from axis. Allows
         * passing of 3D and (3+1)D vectors
         */
        template <bool renorm = true, typename T = F, std::size_t N = 3> requires std::is_arithmetic_v<T> && (N == 3 || N == 4) && (Nr == 4) && (Nc == 4)
        constexpr void prerotate (const sm::vec<T, N>& axis, const T& theta) noexcept
        {
            sm::quaternion<T> q;
            q.template rotate<sm::vec<T, N>, renorm> (axis, theta);
            this->prerotate<T> (q);
        }

        //! Rotation by post-multiplication of a pure rotation matrix: this = this * R
        template <typename T> requires std::is_arithmetic_v<T> && (Nr == 4) && (Nc == 4)
        constexpr void rotate (const sm::quaternion<T>& q) noexcept { *this *= this->pure_rotation (q); }

        /*!
         * Rotate an angle theta radians about axis (specified as std::array). By default, the axis
         * is not required to be normalized because quaternion::rotate will do this.
         *
         * Result: this = this * R (post-multiplication)
         *
         * \tparam renorm If true, renormalize axis to length 1, if false, assume axis has already
         * been renormalized
         *
         * \tparam T type for operations, usually compiler-detected from axis and theta
         *
         * \tparam N Number of elements in the axis vector, compiler-detected from axis. Allows
         * passing of 3D and (3+1)D vectors
         */
        template <bool renorm = true, typename T = F, std::size_t N = 3> requires std::is_arithmetic_v<T> && (N == 3 || N == 4) && (Nr == 4) && (Nc == 4)
        constexpr void rotate (const std::array<T, N>& axis, const T& theta) noexcept
        {
            sm::quaternion<T> q;
            q.template rotate<std::array<T, N>, renorm> (axis, theta);
            this->rotate<T> (q);
        }

        /*!
         * Rotate an angle theta radians about axis (specified as sm::vec). By default, the axis is
         * not required to be normalized because quaternion::rotate will do this.
         *
         * Result: this = this * R (post-multiplication)
         *
         * \tparam renorm If true, renormalize axis to length 1, if false, assume axis has already
         * been renormalized
         *
         * \tparam T type for operations, usually compiler-detected from axis and theta
         *
         * \tparam N Number of elements in the axis vector, compiler-detected from axis. Allows
         * passing of 3D and (3+1)D vectors
         */
        template <bool renorm = true, typename T = F, std::size_t N = 3> requires std::is_arithmetic_v<T> && (N == 3 || N == 4) && (Nr == 4) && (Nc == 4)
        constexpr void rotate (const sm::vec<T, N>& axis, const T& theta) noexcept
        {
            sm::quaternion<T> q;
            q.template rotate<sm::vec<T, N>, renorm> (axis, theta);
            this->rotate<T> (q);
        }

        //! Set this matrix up so that it would rotate a 2D vector by rot_rad radians, anticlockwise.
        template <typename T = F> requires std::is_arithmetic_v<T> && (Nr == 2) && (Nc == 2)
        constexpr void rotate (const T rot_rad) noexcept
        {
            this->arr[0] = sm::cem::cos (rot_rad);
            this->arr[1] = sm::cem::sin (rot_rad);
            this->arr[2] = -this->arr[1]; // -sin
            this->arr[3] = this->arr[0];
        }

        //! Returns the linear part of the 4x4 matrix (the top left 3x3 matrix)
        constexpr sm::mat<F, 3> linear() const noexcept
        {
            if constexpr (Nr != Nc || Nr != 4) { []<bool flag = false>() { static_assert(flag, "valid only for 4x4 matrices"); }(); }

            sm::mat<F, 3> m;

            m[0] = this->arr[0];
            m[1] = this->arr[1];
            m[2] = this->arr[2];
            m[3] = this->arr[4];
            m[4] = this->arr[5];
            m[5] = this->arr[6];
            m[6] = this->arr[8];
            m[7] = this->arr[9];
            m[8] = this->arr[10];

            return m;
        }

        //! Returns the translation part of the 4x4 matrix (top three rows of last column)
        constexpr sm::vec<F, 3> translation() const noexcept
        {
            if constexpr (Nr != Nc || Nr != 4) { []<bool flag = false>() { static_assert(flag, "valid only for 4x4 matrices"); }(); }
            return { this->arr[12], this->arr[13], this->arr[14] };
        }

        /*!
         * Returns the rotation part of the 4x4 matrix (the top left 3x3 matrix, as returned by
         * mat::linear) as a quaternion.
         *
         * This does the equivalent of this->linear().rotation() (that is, you can find
         * mat33::rotation which is the same as this function).
         *
         * It assumes that your 4x4 matrix encodes rotations without scaling. You could use
         * rotationmat44().rotation() to first exclude a uniform or pre-applied scaling.
         *
         * It does *not* check that the matrix determinant is 1 (you could do that first if you need
         * to).
         *
         * It does *not* normalize the generated quaternion before returning it (you could do that
         * afterwards if you need to).
         *
         * Hat tip for the algorithm:
         * https://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/
         */
        constexpr sm::quaternion<F> rotation() const noexcept
        {
            if constexpr ((Nr != 4 && Nr != 3) || Nr != Nc) {
                []<bool flag = false>() { static_assert(flag, "valid only for 4x4 matrices"); }();
            }

            sm::quaternion<F> q;

            if constexpr (Nr == 3) {

                F tr = this->trace();
                if (tr > F{0}) {
                    F S = sm::cem::sqrt (tr + F{1}) * F{2}; // S=4*qw
                    q.w = F{0.25} * S;
                    q.x = (arr[5] - arr[7]) / S;
                    q.y = (arr[6] - arr[2]) / S;
                    q.z = (arr[1] - arr[3]) / S;
                } else if ((arr[0] > arr[4]) && (arr[0] > arr[8])) {
                    F S = sm::cem::sqrt (F{1} + arr[0] - arr[4] - arr[8]) * F{2}; // S=4*qx
                    q.w = (arr[5] - arr[7]) / S;
                    q.x = F{0.25} * S;
                    q.y = (arr[3] + arr[1]) / S;
                    q.z = (arr[6] + arr[2]) / S;
                } else if (arr[4] > arr[8]) {
                    F S = sm::cem::sqrt (F{1} + arr[4] - arr[0] - arr[8]) * F{2}; // S=4*qy
                    q.w = (arr[6] - arr[2]) / S;
                    q.x = (arr[3] + arr[1]) / S;
                    q.y = F{0.25} * S;
                    q.z = (arr[7] + arr[5]) / S;
                } else {
                    F S = sm::cem::sqrt (F{1} + arr[8] - arr[0] - arr[4]) * F{2}; // S=4*qz
                    q.w = (arr[1] - arr[3]) / S;
                    q.x = (arr[6] + arr[2]) / S;
                    q.y = (arr[7] + arr[5]) / S;
                    q.z = F{0.25} * S;
                }

            } else { // Nr == 4

                F tr = arr[0] + arr[5] + arr[10];

                if (tr > F{0}) {
                    F S = sm::cem::sqrt (tr + F{1}) * F{2}; // S=4*qw
                    q.w = F{0.25} * S;
                    q.x = (arr[6] - arr[9]) / S;
                    q.y = (arr[8] - arr[2]) / S;
                    q.z = (arr[1] - arr[4]) / S;
                } else if ((arr[0] > arr[5]) && (arr[0] > arr[10])) {
                    F S = sm::cem::sqrt (F{1} + arr[0] - arr[5] - arr[10]) * F{2}; // S=4*qx
                    q.w = (arr[6] - arr[9]) / S;
                    q.x = F{0.25} * S;
                    q.y = (arr[4] + arr[1]) / S;
                    q.z = (arr[8] + arr[2]) / S;
                } else if (arr[5] > arr[10]) {
                    F S = sm::cem::sqrt (F{1} + arr[5] - arr[0] - arr[10]) * F{2}; // S=4*qy
                    q.w = (arr[8] - arr[2]) / S;
                    q.x = (arr[4] + arr[1]) / S;
                    q.y = F{0.25} * S;
                    q.z = (arr[9] + arr[6]) / S;
                } else {
                    F S = sm::cem::sqrt (F{1} + arr[10] - arr[0] - arr[6]) * F{2}; // S=4*qz
                    q.w = (arr[1] - arr[4]) / S;
                    q.x = (arr[8] + arr[2]) / S;
                    q.y = (arr[9] + arr[6]) / S;
                    q.z = F{0.25} * S;
                }
            }
            return q;
        }

        //! Obtain the rotation, excluding any uniform, or non-uniform-but-applied-before-rotations scaling.
        constexpr sm::mat<F, 3> rotation_mat33() const noexcept
        {
            if constexpr (Nr != Nc || Nr != 4) { []<bool flag = false>() { static_assert(flag, "valid only for 4x4 matrices"); }(); }
            sm::vec<F, 3> c0 = { arr[0], arr[1], arr[2] };
            sm::vec<F, 3> c1 = { arr[4], arr[5], arr[6] };
            sm::vec<F, 3> c2 = { arr[8], arr[9], arr[10] };
            c0 /= c0.length();
            c1 /= c1.length();
            c2 /= c2.length();
            sm::mat<F, 3> m = { c0[0], c0[1], c0[2], c1[0], c1[1], c1[2], c2[0], c2[1], c2[2] };
            return m;
        }

        //! Obtain the rotation, excluding any uniform, or non-uniform-but-applied-before-rotations scaling.
        constexpr sm::mat<F, 4> rotation_mat44() const noexcept
        {
            if constexpr (Nr != Nc || Nr != 4) { []<bool flag = false>() { static_assert(flag, "valid only for 4x4 matrices"); }(); }
            sm::vec<F, 3> c0 = { arr[0], arr[1], arr[2] };
            sm::vec<F, 3> c1 = { arr[4], arr[5], arr[6] };
            sm::vec<F, 3> c2 = { arr[8], arr[9], arr[10] };
            c0 /= c0.length();
            c1 /= c1.length();
            c2 /= c2.length();
            sm::mat<F, 4> m = {
                c0[0], c0[1], c0[2], F{0},
                c1[0], c1[1], c1[2], F{0},
                c2[0], c2[1], c2[2], F{0},
                F{0},  F{0},  F{0},  F{1}
            };
            return m;
        }

        //! Obtain scaling from this matrix, returning as a vector of scale factors
        constexpr sm::vec<F, 3> scaling_vec() const noexcept
        {
            if constexpr (Nr != Nc || Nr != 4) { []<bool flag = false>() { static_assert(flag, "valid only for 4x4 matrices"); }(); }
            return sm::vec<F, 3>{
                sm::cem::sqrt (arr[0] * arr[0] + arr[1] * arr[1] + arr[2] * arr[2]), // length of 1st col
                sm::cem::sqrt (arr[4] * arr[4] + arr[5] * arr[5] + arr[6] * arr[6]),
                sm::cem::sqrt (arr[8] * arr[8] + arr[9] * arr[9] + arr[10] * arr[10])
            };
        }

        //! Obtain scaling from this matrix, returning as a 3x3 mat33
        constexpr sm::mat<F, 3> scaling_mat33() const noexcept
        {
            if constexpr (Nr != Nc || Nr != 4) { []<bool flag = false>() { static_assert(flag, "valid only for 4x4 matrices"); }(); }
            sm::mat<F, 3> m = {
                sm::cem::sqrt (arr[0] * arr[0] + arr[1] * arr[1] + arr[2] * arr[2]),   F{0}, F{0},
                F{0}, sm::cem::sqrt (arr[4] * arr[4] + arr[5] * arr[5] + arr[6] * arr[6]),   F{0},
                F{0}, F{0}, sm::cem::sqrt (arr[8] * arr[8] + arr[9] * arr[9] + arr[10] * arr[10])
            };
            return m;
        }

        //! Obtain scaling from this matrix, returning as a 4x4 mat
        constexpr sm::mat<F, 4> scaling_mat44() const noexcept
        {
            if constexpr (Nr != Nc || Nr != 4) { []<bool flag = false>() { static_assert(flag, "valid only for 4x4 matrices"); }(); }
            sm::mat<F, 4> m = {
                sm::cem::sqrt (arr[0] * arr[0] + arr[1] * arr[1] + arr[2] * arr[2]),   F{0}, F{0}, F{0},
                F{0}, sm::cem::sqrt (arr[4] * arr[4] + arr[5] * arr[5] + arr[6] * arr[6]),   F{0}, F{0},
                F{0}, F{0}, sm::cem::sqrt (arr[8] * arr[8] + arr[9] * arr[9] + arr[10] * arr[10]), F{0},
                F{0}, F{0}, F{0},                                                                  F{1}
            };
            return m;
        }

        //! Add m2 to this matrix
        constexpr void operator+= (const mat<F, Nr, Nc>& m2) noexcept
        {
            for (uint32_t i = 0; i < Nr * Nc; ++i) { this->arr[i] += m2.arr[i]; }
        }

        //! Return this + m2
        constexpr mat<F, Nr, Nc> operator+ (const mat<F, Nr, Nc>& m2) const noexcept
        {
            mat<F, Nr, Nc> m = {};
            for (uint32_t i = 0; i < Nr * Nc; ++i) { m[i] = this->arr[i] + m2.arr[i]; }
            return m;
        }

        //! Add scalar to this matrix
        constexpr void operator+= (const F& f) noexcept
        {
            for (uint32_t i = 0; i < Nr * Nc; ++i) { this->arr[i] += f; }
        }

        //! Return this + scalar
        constexpr mat<F, Nr, Nc> operator+ (const F& f) const noexcept
        {
            mat<F, Nr, Nc> m = {};
            for (uint32_t i = 0; i < Nr * Nc; ++i) { m[i] = this->arr[i] + f; }
            return m;
        }

        //! Subtract m2 from this matrix
        constexpr void operator-= (const mat<F, Nr, Nc>& m2) noexcept
        {
            for (uint32_t i = 0; i < Nr * Nc; ++i) { this->arr[i] -= m2.arr[i]; }
        }

        //! Return this - m2
        constexpr mat<F, Nr, Nc> operator- (const mat<F, Nr, Nc>& m2) const noexcept
        {
            mat<F, Nr, Nc> m = {};
            for (uint32_t i = 0; i < Nr * Nc; ++i) { m[i] = this->arr[i] - m2.arr[i]; }
            return m;
        }

        //! Subtract scalar from this matrix
        constexpr void operator-= (const F& f) noexcept
        {
            for (uint32_t i = 0; i < Nr * Nc; ++i) { this->arr[i] -= f; }
        }

        //! Return this - scalar
        constexpr mat<F, Nr, Nc> operator- (const F& f) const noexcept
        {
            mat<F, Nr, Nc> m = {};
            for (uint32_t i = 0; i < Nr * Nc; ++i) { m[i] = this->arr[i] - f; }
            return m;
        }

        //! Right-multiply this->arr with m2
        template<typename Fy=F, uint32_t Nry = Nr, uint32_t Ncy = Nc> requires (Nc == Nry)
        constexpr void operator*= (const mat<Fy, Nry, Ncy>& m2) noexcept
        {
            std::array<F, Nr * Ncy> m;

            if constexpr (Nr == 2 && Nc == 2) {
                // Top row
                m[0] = this->arr[0] * m2.arr[0] + this->arr[2] * m2.arr[1];
                m[2] = this->arr[0] * m2.arr[2] + this->arr[2] * m2.arr[3];
                // Second row
                m[1] = this->arr[1] * m2.arr[0] + this->arr[3] * m2.arr[1];
                m[3] = this->arr[1] * m2.arr[2] + this->arr[3] * m2.arr[3];
            } else if constexpr (Nr == 3 && Nc == 3) {
                // Top row
                m[0] = this->arr[0] * m2.arr[0] + this->arr[3] * m2.arr[1] + this->arr[6] * m2.arr[2];
                m[3] = this->arr[0] * m2.arr[3] + this->arr[3] * m2.arr[4] + this->arr[6] * m2.arr[5];
                m[6] = this->arr[0] * m2.arr[6] + this->arr[3] * m2.arr[7] + this->arr[6] * m2.arr[8];
                // Second row
                m[1] = this->arr[1] * m2.arr[0] + this->arr[4] * m2.arr[1] + this->arr[7] * m2.arr[2];
                m[4] = this->arr[1] * m2.arr[3] + this->arr[4] * m2.arr[4] + this->arr[7] * m2.arr[5];
                m[7] = this->arr[1] * m2.arr[6] + this->arr[4] * m2.arr[7] + this->arr[7] * m2.arr[8];
                // Third row
                m[2] = this->arr[2] * m2.arr[0] + this->arr[5] * m2.arr[1] + this->arr[8] * m2.arr[2];
                m[5] = this->arr[2] * m2.arr[3] + this->arr[5] * m2.arr[4] + this->arr[8] * m2.arr[5];
                m[8] = this->arr[2] * m2.arr[6] + this->arr[5] * m2.arr[7] + this->arr[8] * m2.arr[8];
            } else if constexpr (Nr == 4 && Nc == 4) {
                // Top row
                m[0] = this->arr[0] * m2.arr[0] + this->arr[4] * m2.arr[1] + this->arr[8] * m2.arr[2] + this->arr[12] * m2.arr[3];
                m[4] = this->arr[0] * m2.arr[4] + this->arr[4] * m2.arr[5] + this->arr[8] * m2.arr[6] + this->arr[12] * m2.arr[7];
                m[8] = this->arr[0] * m2.arr[8] + this->arr[4] * m2.arr[9] + this->arr[8] * m2.arr[10] + this->arr[12] * m2.arr[11];
                m[12] = this->arr[0] * m2.arr[12] + this->arr[4] * m2.arr[13] + this->arr[8] * m2.arr[14] + this->arr[12] * m2.arr[15];
                // Second row
                m[1] = this->arr[1] * m2.arr[0] + this->arr[5] * m2.arr[1] + this->arr[9] * m2.arr[2] + this->arr[13] * m2.arr[3];
                m[5] = this->arr[1] * m2.arr[4] + this->arr[5] * m2.arr[5] + this->arr[9] * m2.arr[6] + this->arr[13] * m2.arr[7];
                m[9] = this->arr[1] * m2.arr[8] + this->arr[5] * m2.arr[9] + this->arr[9] * m2.arr[10] + this->arr[13] * m2.arr[11];
                m[13] = this->arr[1] * m2.arr[12] + this->arr[5] * m2.arr[13] + this->arr[9] * m2.arr[14] + this->arr[13] * m2.arr[15];
                // Third row
                m[2] = this->arr[2] * m2.arr[0] + this->arr[6] * m2.arr[1] + this->arr[10] * m2.arr[2] + this->arr[14] * m2.arr[3];
                m[6] = this->arr[2] * m2.arr[4] + this->arr[6] * m2.arr[5] + this->arr[10] * m2.arr[6] + this->arr[14] * m2.arr[7];
                m[10] = this->arr[2] * m2.arr[8] + this->arr[6] * m2.arr[9] + this->arr[10] * m2.arr[10] + this->arr[14] * m2.arr[11];
                m[14] = this->arr[2] * m2.arr[12] + this->arr[6] * m2.arr[13] + this->arr[10] * m2.arr[14] + this->arr[14] * m2.arr[15];
                // Bottom row
                m[3] = this->arr[3] * m2.arr[0] + this->arr[7] * m2.arr[1] + this->arr[11] * m2.arr[2] + this->arr[15] * m2.arr[3];
                m[7] = this->arr[3] * m2.arr[4] + this->arr[7] * m2.arr[5] + this->arr[11] * m2.arr[6] + this->arr[15] * m2.arr[7];
                m[11] = this->arr[3] * m2.arr[8] + this->arr[7] * m2.arr[9] + this->arr[11] * m2.arr[10] + this->arr[15] * m2.arr[11];
                m[15] = this->arr[3] * m2.arr[12] + this->arr[7] * m2.arr[13] + this->arr[11] * m2.arr[14] + this->arr[15] * m2.arr[15];
            } else {
                // General case left matrix is this->arr, right matrix is m2
                for (uint32_t r = 0; r < Nr; ++r) {
                    for (uint32_t cy = 0; cy < Ncy; ++cy) {
                        m.arr[r * Ncy + cy] = F{0};
                        for (uint32_t c = 0; c < Nc; ++c) {
                            m[r * Ncy + cy] += this->arr[r * Nc + c] * m2.arr[cy * Nry + c];
                        }
                    }
                }
            }

            this->arr.swap (m);
        }

        //! Right multiply this->arr with m2.arr. Make general NOW
        template<typename Fy=F, uint32_t Nry = Nr, uint32_t Ncy = Nc> requires (Nc == Nry)
        constexpr mat<F, Nr, Ncy> operator* (const mat<Fy, Nry, Ncy>& m2) const noexcept
        {
            mat<F, Nr, Ncy> m;

            if constexpr (Nr == 2 && Nc == 2) {
                // Top row
                m.arr[0] = this->arr[0] * m2.arr[0] + this->arr[2] * m2.arr[1];
                m.arr[2] = this->arr[0] * m2.arr[2] + this->arr[2] * m2.arr[3];
                // Second row
                m.arr[1] = this->arr[1] * m2.arr[0] + this->arr[3] * m2.arr[1];
                m.arr[3] = this->arr[1] * m2.arr[2] + this->arr[3] * m2.arr[3];

            } else if constexpr (Nr == 3 && Nc == 3) {
                // Top row
                m.arr[0] = this->arr[0] * m2.arr[0] + this->arr[3] * m2.arr[1] + this->arr[6] * m2.arr[2];
                m.arr[3] = this->arr[0] * m2.arr[3] + this->arr[3] * m2.arr[4] + this->arr[6] * m2.arr[5];
                m.arr[6] = this->arr[0] * m2.arr[6] + this->arr[3] * m2.arr[7] + this->arr[6] * m2.arr[8];
                // Second row
                m.arr[1] = this->arr[1] * m2.arr[0] + this->arr[4] * m2.arr[1] + this->arr[7] * m2.arr[2];
                m.arr[4] = this->arr[1] * m2.arr[3] + this->arr[4] * m2.arr[4] + this->arr[7] * m2.arr[5];
                m.arr[7] = this->arr[1] * m2.arr[6] + this->arr[4] * m2.arr[7] + this->arr[7] * m2.arr[8];
                // Third row
                m.arr[2] = this->arr[2] * m2.arr[0] + this->arr[5] * m2.arr[1] + this->arr[8] * m2.arr[2];
                m.arr[5] = this->arr[2] * m2.arr[3] + this->arr[5] * m2.arr[4] + this->arr[8] * m2.arr[5];
                m.arr[8] = this->arr[2] * m2.arr[6] + this->arr[5] * m2.arr[7] + this->arr[8] * m2.arr[8];

            } else if constexpr (Nr == 4 && Nc == 4) {

                // Top row
                m.arr[0] = this->arr[0] * m2.arr[0] + this->arr[4] * m2.arr[1] + this->arr[8] * m2.arr[2] + this->arr[12] * m2.arr[3];
                m.arr[4] = this->arr[0] * m2.arr[4] + this->arr[4] * m2.arr[5] + this->arr[8] * m2.arr[6] + this->arr[12] * m2.arr[7];
                m.arr[8] = this->arr[0] * m2.arr[8] + this->arr[4] * m2.arr[9] + this->arr[8] * m2.arr[10] + this->arr[12] * m2.arr[11];
                m.arr[12] = this->arr[0] * m2.arr[12] + this->arr[4] * m2.arr[13] + this->arr[8] * m2.arr[14] + this->arr[12] * m2.arr[15];
                // Second row
                m.arr[1] = this->arr[1] * m2.arr[0] + this->arr[5] * m2.arr[1] + this->arr[9] * m2.arr[2] + this->arr[13] * m2.arr[3];
                m.arr[5] = this->arr[1] * m2.arr[4] + this->arr[5] * m2.arr[5] + this->arr[9] * m2.arr[6] + this->arr[13] * m2.arr[7];
                m.arr[9] = this->arr[1] * m2.arr[8] + this->arr[5] * m2.arr[9] + this->arr[9] * m2.arr[10] + this->arr[13] * m2.arr[11];
                m.arr[13] = this->arr[1] * m2.arr[12] + this->arr[5] * m2.arr[13] + this->arr[9] * m2.arr[14] + this->arr[13] * m2.arr[15];
                // Third row
                m.arr[2] = this->arr[2] * m2.arr[0] + this->arr[6] * m2.arr[1] + this->arr[10] * m2.arr[2] + this->arr[14] * m2.arr[3];
                m.arr[6] = this->arr[2] * m2.arr[4] + this->arr[6] * m2.arr[5] + this->arr[10] * m2.arr[6] + this->arr[14] * m2.arr[7];
                m.arr[10] = this->arr[2] * m2.arr[8] + this->arr[6] * m2.arr[9] + this->arr[10] * m2.arr[10] + this->arr[14] * m2.arr[11];
                m.arr[14] = this->arr[2] * m2.arr[12] + this->arr[6] * m2.arr[13] + this->arr[10] * m2.arr[14] + this->arr[14] * m2.arr[15];
                // Bottom row
                m.arr[3] = this->arr[3] * m2.arr[0] + this->arr[7] * m2.arr[1] + this->arr[11] * m2.arr[2] + this->arr[15] * m2.arr[3];
                m.arr[7] = this->arr[3] * m2.arr[4] + this->arr[7] * m2.arr[5] + this->arr[11] * m2.arr[6] + this->arr[15] * m2.arr[7];
                m.arr[11] = this->arr[3] * m2.arr[8] + this->arr[7] * m2.arr[9] + this->arr[11] * m2.arr[10] + this->arr[15] * m2.arr[11];
                m.arr[15] = this->arr[3] * m2.arr[12] + this->arr[7] * m2.arr[13] + this->arr[11] * m2.arr[14] + this->arr[15] * m2.arr[15];

            } else {
                // General case left matrix is this->arr, right matrix is m2.arr
                for (uint32_t r = 0; r < Nr; ++r) {
                    for (uint32_t cy = 0; cy < Ncy; ++cy) {
                        m.arr[r * Ncy + cy] = F{0};
                        for (uint32_t c = 0; c < Nc; ++c) {
                            m.arr[r * Ncy + cy] += this->arr[r * Nc + c] * m2.arr[cy * Nry + c];
                        }
                    }
                }
            }

            return m;
        }

        //! Do matrix times vector multiplication, v = mat * v1
        constexpr std::array<F, Nr> operator* (const std::array<F, Nr>& v1) const noexcept
        {
            std::array<F, Nr> v = {};
            for (uint32_t r = 0; r < Nr; ++r) {
                for (uint32_t c = 0; c < Nc; ++c) { v[r] += this->arr[r + c * Nr] * v1[c]; }
            }
            return v;
        }

        //! Do matrix times vector multiplication, v = mat * v1
        constexpr sm::vec<F, Nr> operator* (const sm::vec<F, Nr>& v1) const noexcept
        {
            sm::vec<F, Nr> v = {};
            for (uint32_t r = 0; r < Nr; ++r) {
                for (uint32_t c = 0; c < Nc; ++c) { v[r] += this->arr[r + c * Nr] * v1[c]; }
            }
            return v;
        }

        //! Do matrix times vector multiplication, v = mat * v1, for the special case that we have a 4x4 matrix and a 3D vector
        constexpr sm::vec<F, Nr> operator* (const sm::vec<F, Nr - 1>& v1) const noexcept
        {
            if constexpr (Nr != Nc || Nr != 4) { []<bool flag = false>() { static_assert(flag, "valid only for 4x4 matrices"); }(); }
            sm::vec<F, 4> v;
            v[0] = this->arr[0] * v1[0] + this->arr[4] * v1[1] + this->arr[8] * v1[2] + this->arr[12];
            v[1] = this->arr[1] * v1[0] + this->arr[5] * v1[1] + this->arr[9] * v1[2] + this->arr[13];
            v[2] = this->arr[2] * v1[0] + this->arr[6] * v1[1] + this->arr[10] * v1[2] + this->arr[14];
            v[3] = this->arr[3] * v1[0] + this->arr[7] * v1[1] + this->arr[11] * v1[2] + this->arr[15];
            return v;
        }

        //! *= operator for a scalar value.
        template <typename T=F> requires std::is_arithmetic_v<T>
        constexpr void operator*= (const T& f) noexcept
        {
            for (uint32_t i = 0; i < Nr * Nc; ++i) { this->arr[i] *= f; }
        }

        //! Equality operator. True if all elements match
        constexpr bool operator== (const mat<F, Nr, Nc>& rhs) const noexcept
        {
            uint32_t ndiff = 0;
            for (uint32_t i = 0; i < Nr * Nc && ndiff == 0; ++i) {
                ndiff += this->arr[i] == rhs.arr[i] ? 0 : 1;
            }
            return ndiff == 0;
        }

        //! Not equals
        constexpr bool operator!= (const mat<F, Nr, Nc>& rhs) const noexcept
        {
            uint32_t ndiff = 0;
            for (uint32_t i = 0; i < Nr * Nc && ndiff == 0; ++i) {
                ndiff += this->arr[i] == rhs.arr[i] ? 0 : 1;
            }
            return ndiff > 0;
        }

        //! Transpose this matrix
        constexpr void transpose_inplace() noexcept
        {
            if constexpr (Nr != Nc) { []<bool flag = false>() { static_assert(flag, "valid only for square matrices"); }(); }

            constexpr uint32_t N_diamond = ((Nr * Nc) - Nr ) / 2;

            std::array<F, N_diamond> a;

            uint32_t i = 0;
            for (uint32_t c = 0; c < (Nc / 2) + 1; ++c) {
                for (uint32_t r = c + 1; r < Nr; ++r) {
                    a[i++] = this->arr[c * Nr + r];
                    this->arr[c * Nr + r] = this->arr[r * Nr + c];
                }
            }
            i = 0;
            for (uint32_t c = 0; c < (Nc / 2) + 1; ++c) {
                for (uint32_t r = c + 1; r < Nr; ++r) {
                    this->arr[r * Nr + c] = a[i++];
                }
            }
        }

        //! Return the matrix transposed
        constexpr mat<F, Nc, Nr> transpose() const noexcept
        {
            if constexpr (Nr != Nc) { []<bool flag = false>() { static_assert(flag, "valid only for square matrices"); }(); }

            constexpr uint32_t N_diamond = ((Nr * Nc) - Nr ) / 2;

            std::array<F, N_diamond> a;

            mat<F, Nc, Nr> m = *this;

            uint32_t i = 0;
            for (uint32_t c = 0; c < (Nc / 2) + 1; ++c) {
                for (uint32_t r = c + 1; r < Nr; ++r) {
                    a[i++] = this->arr[c * Nr + r];
                    m[c * Nr + r] = this->arr[r * Nr + c];
                }
            }
            i = 0;
            for (uint32_t c = 0; c < (Nc / 2) + 1; ++c) {
                for (uint32_t r = c + 1; r < Nr; ++r) {
                    m[r * Nr + c] = a[i++];
                }
            }

            return m;
        }

        //! Transpose the matrix @cm, returning the transposed version.
        static constexpr std::array<F, Nr * Nc> transpose (const std::array<F, Nr * Nc>& cm) noexcept
        {
            if constexpr (Nr != Nc) { []<bool flag = false>() { static_assert(flag, "valid only for square matrices"); }(); }

            constexpr uint32_t N_diamond = ((Nr * Nc) - Nr ) / 2;

            std::array<F, N_diamond> a;

            std::array<F, Nr * Nc> m;

            // Copy diagonal to m
            for (uint32_t c = 0; c < Nc; ++c) { m[c * Nr + c] = cm[c * Nr + c]; }

            uint32_t i = 0;
            for (uint32_t c = 0; c < (Nc / 2) + 1; ++c) {
                for (uint32_t r = c + 1; r < Nr; ++r) {
                    a[i++] = cm[c * Nr + r];
                    m[c * Nr + r] = cm[r * Nr + c];
                }
            }
            i = 0;
            for (uint32_t c = 0; c < (Nc / 2) + 1; ++c) {
                for (uint32_t r = c + 1; r < Nr; ++r) {
                    m[r * Nr + c] = a[i++];
                }
            }

            return m;
        }

        /*!
         * Make a (frustrum) perspective projection in this matrix
         *
         * @fovDeg Field of view, in degrees. Measured from the top of the field to
         * the bottom of the field (rather than from the left to the right).
         *
         * @aspect The field's aspect ratio. For a field which is wider than it is
         * high, this will be >1. That is, this is "the number of multiples of the
         * height that the width is"
         *
         * @zNear The near/projection plane.
         *
         * @zFar The far plane.
         */
        constexpr void perspective_inplace (F fovDeg, F aspect, F zNear, F zFar) noexcept
        {
            if constexpr (Nr != Nc || Nr != 4) { []<bool flag = false>() { static_assert(flag, "valid only for 4x4 matrices"); }(); }
            (*this) = sm::mat<F, 4>::perspective (fovDeg, aspect, zNear, zFar);
        }

        /*!
         * Make a (frustrum) perspective projection
         *
         * @fovDeg Field of view, in degrees. Measured from the top of the field to
         * the bottom of the field (rather than from the left to the right).
         *
         * @aspect The field's aspect ratio. For a field which is wider than it is
         * high, this will be >1. That is, this is "the number of multiples of the
         * height that the width is"
         *
         * @zNear The near/projection plane.
         *
         * @zFar The far plane.
         *
         * \return the perspective projection matrix
         */
        static constexpr sm::mat<F, 4> perspective (F fovDeg, F aspect, F zNear, F zFar) noexcept
        {
            if constexpr (Nr != Nc || Nr != 4) { []<bool flag = false>() { static_assert(flag, "valid only for 4x4 matrices"); }(); }

            sm::mat<F, 4> m;

            // Bail out if the projection volume is zero-sized.
            if (zNear == zFar || aspect == F{0}) { return m; }

            F fovRad_ov2 = fovDeg * sm::mathconst<F>::pi_over_360; // fovDeg/2 converted to radians
            F sineFov = sm::cem::sin (fovRad_ov2);
            if (sineFov == F{0}) { return m; }
            F cotanFov = sm::cem::cos (fovRad_ov2) / sineFov;
            F clip = zFar - zNear;

            // Build perspective matrix
            m.arr.fill (F{0});
            m.arr[0] = cotanFov / aspect; // n/(width/2) = 2n/width, or generally 2n/r-l
            m.arr[5] = cotanFov;          // n/(height/2) = 2n/height, or generally 2n/t-b
            // For fully general frustrum not centered on the z axis, we would add these:
            //m.arr[8] = r+l/r-l
            //m.arr[9] = t+b/t-b
            m.arr[10] = -(zNear + zFar) / clip;
            m.arr[11] = F{-1};
            m.arr[14] = -(F{2} * zNear * zFar) / clip;

            return m;
        }

        /*!
         * Make an orthographic projection into this matrix
         *
         * \param rt Right-top coordinate. rt[0] is 'x' and thus the right and rt[1] ('y') is the top
         *
         * \param lb Left-bottom coordinate. lb[0] is 'x' and thus the left and lb[1] 'y' and is the bottom
         *
         * \param zFar The 'far' z coordinate of the canonical viewing volume
         *
         * \param zNear The 'near' z coordinate of the canonical viewing volume
         */
        constexpr void orthographic_inplace (const sm::vec<F, 2>& lb, const sm::vec<F, 2>& rt,
                                             const F zNear, const F zFar) noexcept
        {
            if constexpr (Nr != Nc || Nr != 4) { []<bool flag = false>() { static_assert(flag, "valid only for 4x4 matrices"); }(); }
            (*this) = sm::mat<F, 4>::orthographic (lb, rt, zNear, zFar);
        }

        /*!
         * Make an orthographic projection, returning as mat
         *
         * \param rt Right-top coordinate. rt[0] is 'x' and thus the right and rt[1] ('y') is the top
         *
         * \param lb Left-bottom coordinate. lb[0] is 'x' and thus the left and lb[1] 'y' and is the bottom
         *
         * \param zFar The 'far' z coordinate of the canonical viewing volume
         *
         * \param zNear The 'near' z coordinate of the canonical viewing volume
         */
        static constexpr sm::mat<F, 4> orthographic (const sm::vec<F, 2>& lb, const sm::vec<F, 2>& rt,
                                                     const F zNear, const F zFar) noexcept
        {
            if constexpr (Nr != Nc || Nr != 4) { []<bool flag = false>() { static_assert(flag, "valid only for 4x4 matrices"); }(); }

            sm::mat<F, 4> m;

            if (zNear == zFar) { return m; }

            // Build orthographic matrix
            m.arr.fill (F{0});
            m.arr[0] = F{2} / (rt[0] - lb[0]);              //      2/(r-l)
            m.arr[5] = F{2} / (rt[1] - lb[1]);              //      2/(t-b)
            m.arr[10] = F{-2} / (zFar - zNear);             //     -2/(f-n)
            m.arr[12] = -(rt[0] + lb[0]) / (rt[0] - lb[0]); // -(r+l)/(r-l)
            m.arr[13] = -(rt[1] + lb[1]) / (rt[1] - lb[1]); // -(t+b)/(t-b)
            m.arr[14] = -(zFar + zNear) / (zFar - zNear);   // -(f+n)/(f-n)
            m.arr[15] = F{1};

            return m;
        }

        //! Overload the stream output operator
        friend std::ostream& operator<< <F> (std::ostream& os, const mat<F, Nr, Nc>& tm);
    };

    template <typename F, uint32_t Nr, uint32_t Nc>
    std::ostream& operator<< (std::ostream& os, const mat<F, Nr, Nc>& tm)
    {
        os << tm.str();
        return os;
    }

} // namespace sm
