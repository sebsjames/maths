// -*- C++ -*-
/*!
 * This file is part of sebsjames/maths, a library of maths code for modern C++
 *
 * See https://github.com/sebsjames/maths
 *
 * \file
 *
 * Provides sm::winder, a class to compute the winding number of a boundary with
 * respect to a given coordinate.
 *
 * \author Seb James
 * \date May 2020
 */

#pragma once

#include <memory>
//#include <cmath>
#include <type_traits>

#include <sm/mathconst>
#include <sm/trait_tests>
#include <sm/vec>

namespace sm
{
    /*!
     * A winding number class
     *
     * Implements axis crossing algorithm. see
     * https://www.engr.colostate.edu/~dga/documents/papers/point_in_polygon.pdf for some extra info
     *
     * This class is specialised so that the container which contains the path
     * coordinates can be any of the straightforward STL containers such as std::vector
     * or std::list (but not std::map). The coordinate should be some type which has one
     * of the following: .first and .second attributes (such as std::pair), .x and .y
     * attributes, .x() and .y() methods or the ability to
     * access members in an array-like fashion (std::vector or sm::vec). For example:
     *
     *\code{c++}
     *  std::list<sm::vec<float, 2>> path;
     *  // Code which populates path goes here
     *  sm::winder w(path);
     *  sm::vec<float, 2> pixel = {0.7, 0.6};
     *  int winding_number = w.wind (pixel);
     *\endcode
     *
     * \tparam T the (2D) coordinate type (this might be cv::Point, sm::BezCoord,
     * sm::vvec, sm::vec, std::array or std::vector)
     *
     * \tparam Container Something like an std::vector, std::list or std::array,
     * containing a path of points. The template-template is not flexible enough for
     * Container to be std::map.
     */
    template<typename C>
    class winder
    {
        // C must be copyable. This should ensure it has a value_type, too.
        static_assert (sm::is_copyable_container<C>::value == true);

        using T = typename C::value_type;

        using T_el = typename T::value_type;

        static constexpr bool debug_mode = true;
        static constexpr bool debug_extra = false;

    public:
        //! Construct with the boundary reference.
        winder (const C& _boundary) : boundary(_boundary) {}

        //! Compute the winding number of the coordinate px with respect to the boundary.
        int wind (const T& px)
        {
            double wd = 0.0;
            T_el r = T_el{0};

            this->pt_last = this->shiftpt (px, this->boundary.back());

            for (std::size_t i = 0; i < this->boundary.size(); ++i) {

                sm::vec<T_el, 2> pt = this->shiftpt (px, this->boundary[i]);
                if (pt[1] * pt_last[1] < T_el{0}) {
                    // We cross the x axis
                    r = pt_last[0] + pt_last[1] * (pt[0] - pt_last[0]) / (pt_last[1] - pt[1]); // x coord of intersection
                    if (r > T_el{0}) { // crosses positive x axis
                        if (pt_last[1] < T_el{0}) {
                            if constexpr (debug_extra == true) { std::cout << "+x,"; }
                            wd += 1;
                        } else {
                            if constexpr (debug_extra == true) { std::cout << "-x,"; }
                            wd -= 1;
                        }
                    } else if (pt_last[1] == T_el{0} && pt_last[0] > T_el{0}) { // pt_last is on positive axis
                        if (pt[1] > T_el{0}) {
                            if constexpr (debug_extra == true) { std::cout << "PL+.5,"; }
                            wd += 0.5;
                        } else {
                            if constexpr (debug_extra == true) { std::cout << "PL-.5,"; }
                            wd -= 0.5;
                        }
                    } else if (pt[1] == T_el{0} && pt[0] > T_el{0}) { // pt is on the positive x axis
                        if (pt_last[1] < T_el{0}) {
                            if constexpr (debug_extra == true) { std::cout << "PT+.5,"; }
                            wd += 0.5;
                        } else {
                            if constexpr (debug_extra == true) { std::cout << "PT-.5,"; }
                            wd -= 0.5;
                        }
                    }
                }
                pt_last = pt;
            }
            int w = static_cast<int>(std::round (wd));
            return w;
        }

    private:

        sm::vec<T_el, 2> shiftpt (const T& px, const T& bp)
        {
            if constexpr (debug_extra == true) { std::cout << "Boundary point " << bp << std::endl; }
            // Get angle from px to bp. First create pt, the vector pointing from px to
            // bp whose angle we will calculate.
            sm::vec<T_el, 2> pt;
            if constexpr (array_access_possible<T>::value == true) {
                // In this case, T is a vector or array like thing
                if constexpr (has_subtraction<T>::value == true) {
                    if constexpr (debug_extra == true) { std::cout << "has subtraction operator\n"; }
                    pt = bp - px;
                } else {
                    if constexpr (debug_extra == true) { std::cout << "subtracting array elements\n"; }
                    pt[0] = bp[0] - px[0];
                    pt[1] = bp[1] - px[1];
                }

            } else if constexpr (has_firstsecond_members<T>::value == true) {
                // In this case, T is presumably a std::pair
                pt[0] = bp.first - px.first;
                pt[1] = bp.second - px.second;

            } else {
                // cv::Point, sm::BezCoord should fall through here.
                if constexpr (has_subtraction<T>::value == true) {
                    if constexpr (debug_extra == true) { std::cout << "has subtraction\n"; }
                    pt = bp - px;
                } else if constexpr (has_xy_members<T>::value == true) {
                    pt[0] = bp.x - px.x;
                    pt[1] = bp.y - px.y;
                } else {
                    throw std::runtime_error ("Template code failed to find out how to subtract one coordinate from another.");
                }
            }

            return pt;
        }

        //! Member reference to the boundary
        const C& boundary;
        //! The angle of the last boundary point
        sm::vec<T_el, 2> pt_last;
    };

} // namespace sm
