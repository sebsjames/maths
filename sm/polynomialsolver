// -*- C++ -*-
/*!
 * See https://github.com/sebsjames/maths
 *
 * General polynomial solver for finding roots of polynomials of degree n.
 *
 * This header provides:
 * - PolynomialSolver<F>: Solves polynomial equations a_n*x^n + ... + a_1*x + a_0 = 0
 *
 * Features:
 * - Analytical solutions for degrees 1-4:
 *   * Linear: Direct solution
 *   * Quadratic: Quadratic formula
 *   * Cubic: Cardano's method
 *   * Quartic: Ferrari's method
 * - Numerical Durand-Kerner (Weierstrass) algorithm for degree > 4
 * - Handles real and complex roots, multiple roots, degenerate cases
 *
 * Usage:
 *   #include <sm/polynomialsolver>
 *   sm::vvec<double> coeffs = {6.0, -5.0, 1.0};  // [a0, a1, a2] for x^2 - 5x + 6 = 0
 *   auto roots = PolynomialSolver<double>::solve(coeffs);  // Returns sm::vvec<std::complex<double>>
 *   auto realRoots = PolynomialSolver<double>::solveReal(coeffs);  // Returns sm::vvec<double>
 *
 * Notes:
 * - Coefficient order is [a0, a1, ..., an] for a_n*x^n + ... + a_1*x + a_0 = 0
 * - Returns complex roots (may be real with zero imaginary part)
 * - Default numerical epsilon is 1e-14
 * - Requires C++20
 *
 * See test_polynomial_solver.cpp in mathplot/maths/tests/ for comprehensive examples
 */

#pragma once

#include <sm/vvec>
#include <complex>
#include <cmath>
#include <algorithm>
#include <stdexcept>

template <typename F = double>
class PolynomialSolver {
public:
    /**
     * Solve polynomial: a[n]*x^n + a[n-1]*x^(n-1) + ... + a[1]*x + a[0] = 0
     * @param coeffs Coefficients from lowest to highest degree [a0, a1, ..., an]
     * @return Vector of complex roots
     */
    static sm::vvec<std::complex<F>> solve(const sm::vvec<F>& coeffs) {
        if (coeffs.empty()) {
            throw std::invalid_argument("Empty coefficient vector");
        }
        
        sm::vvec<F> c = coeffs;
        removeLeadingZeros(c);
        
        if (c.empty() || (c.size() == 1 && std::abs(c[0]) < EPSILON)) {
            throw std::invalid_argument("All coefficients are zero");
        }
        
        int degree = c.size() - 1;
        
        // Handle constant polynomial
        if (degree == 0) {
            return {}; // No roots
        }
        
        // Normalize so that leading coefficient is 1
        F leading = c[degree];
        if (std::abs(leading) < EPSILON) {
            throw std::invalid_argument("Leading coefficient is zero");
        }
        
        for (auto& coeff : c) {
            coeff /= leading;
        }
        
        // Use analytical solutions for degrees 1-4
        switch (degree) {
            case 1:
                return solveLinear(c[1], c[0]);
            case 2:
                return solveQuadratic(c[2], c[1], c[0]);
            case 3:
                return solveCubic(c[3], c[2], c[1], c[0]);
            case 4:
                return solveQuartic(c[4], c[3], c[2], c[1], c[0]);
            default:
                // Use numerical method for higher degrees
                return solveDurandKerner(c);
        }
    }
    
    /**
     * Get only real roots (imaginary part < tolerance)
     * @param coeffs Coefficients from lowest to highest degree
     * @param tolerance Threshold for considering a root as real
     * @return Vector of real roots
     */
    static sm::vvec<F> solveReal(const sm::vvec<F>& coeffs, F tolerance = F{1e-10}) {
        sm::vvec<std::complex<F>> complexRoots = solve(coeffs);
        sm::vvec<F> realRoots;
        
        for (const std::complex<F>& root : complexRoots) {
            if (std::abs(root.imag()) < tolerance) {
                realRoots.push_back(root.real());
            }
        }
        return realRoots;
    }
    
private:
    static constexpr F EPSILON = F{1e-14};
    static constexpr int MAX_ITERATIONS = 100;
    
    // Analytical solvers for specific degrees
    static sm::vvec<std::complex<F>> solveLinear(F a1, F a0) {
        // a1*x + a0 = 0
        // x = -a0/a1
        return {std::complex<F>(-a0 / a1, F{0})};
    }
    
    static sm::vvec<std::complex<F>> solveQuadratic(F a2, F a1, F a0) {
        // a2*x^2 + a1*x + a0 = 0
        // x = (-a1 Â± sqrt(a1^2 - 4*a2*a0)) / (2*a2)
        
        F discriminant = a1 * a1 - F{4} * a2 * a0;
        
        if (discriminant >= F{0}) {
            F sqrtD = std::sqrt(discriminant);
            F r1 = (-a1 + sqrtD) / (F{2} * a2);
            F r2 = (-a1 - sqrtD) / (F{2} * a2);
            return {std::complex<F>(r1, F{0}), std::complex<F>(r2, F{0})};
        } else {
            F realPart = -a1 / (F{2} * a2);
            F imagPart = std::sqrt(-discriminant) / (F{2} * a2);
            return {std::complex<F>(realPart, imagPart), std::complex<F>(realPart, -imagPart)};
        }
    }
    
    static sm::vvec<std::complex<F>> solveCubic(F a3, F a2, F a1, F a0) {
        // Solve x^3 + a2*x^2 + a1*x + a0 = 0 using Cardano's method
        // Leading coefficient a3 must be 1 (monic polynomial)
        if (std::abs(a3 - F{1}) > EPSILON) {
            throw std::invalid_argument("solveCubic expects monic polynomial (leading coefficient = 1)");
        }
        
        // Convert to depressed cubic: t^3 + p*t + q = 0
        F p = a1 - a2 * a2 / F{3};
        F q = F{2} * a2 * a2 * a2 / F{27} - a2 * a1 / F{3} + a0;
        
        F discriminant = -(F{4} * p * p * p + F{27} * q * q);
        
        sm::vvec<std::complex<F>> roots;
        
        if (discriminant > EPSILON) {
            // Three distinct real roots
            F m = F{2} * std::sqrt(-p / F{3});
            F theta = std::acos(F{3} * q / (p * m)) / F{3};
            F offset = -a2 / F{3};
            
            roots.push_back(std::complex<F>(m * std::cos(theta) + offset, F{0}));
            roots.push_back(std::complex<F>(m * std::cos(theta - F{2} * F(M_PI) / F{3}) + offset, F{0}));
            roots.push_back(std::complex<F>(m * std::cos(theta - F{4} * F(M_PI) / F{3}) + offset, F{0}));
        } else {
            // One real root and two complex conjugate roots
            F offset = -a2 / F{3};
            
            if (std::abs(p) < EPSILON && std::abs(q) < EPSILON) {
                // Special case: p = 0 and q = 0 (triple root at origin)
                F t = -std::cbrt(q);
                roots.push_back(std::complex<F>(t + offset, F{0}));
                roots.push_back(std::complex<F>(t + offset, F{0}));
                roots.push_back(std::complex<F>(t + offset, F{0}));
            } else {
                F disc = q * q / F{4} + p * p * p / F{27};
                F sqrtDisc = std::sqrt(std::abs(disc));
                
                std::complex<F> u, v;
                if (disc >= F{0}) {
                    F val1 = -q / F{2} + sqrtDisc;
                    F val2 = -q / F{2} - sqrtDisc;
                    u = std::pow(std::complex<F>(val1, F{0}), F{1} / F{3});
                    v = std::pow(std::complex<F>(val2, F{0}), F{1} / F{3});
                } else {
                    std::complex<F> w(-q / F{2}, sqrtDisc);
                    u = std::pow(w, F{1} / F{3});
                    v = std::conj(u);
                }
                
                std::complex<F> omega(-F{0.5}, std::sqrt(F{3}) / F{2}); // Cube root of unity
                
                std::complex<F> t0 = u + v;
                std::complex<F> t1 = omega * u + std::conj(omega) * v;
                std::complex<F> t2 = std::conj(omega) * u + omega * v;
                
                roots.push_back(t0 + offset);
                roots.push_back(t1 + offset);
                roots.push_back(t2 + offset);
            }
        }
        
        return roots;
    }
    
    static sm::vvec<std::complex<F>> solveQuartic(F a4, F a3, F a2, F a1, F a0) {
        // Solve x^4 + a3*x^3 + a2*x^2 + a1*x + a0 = 0 using Ferrari's method
        // Leading coefficient a4 must be 1 (monic polynomial)
        if (std::abs(a4 - F{1}) > EPSILON) {
            throw std::invalid_argument("solveQuartic expects monic polynomial (leading coefficient = 1)");
        }
        
        // Convert to depressed quartic: y^4 + p*y^2 + q*y + r = 0
        F p = a2 - F{3} * a3 * a3 / F{8};
        F q = a3 * a3 * a3 / F{8} - a3 * a2 / F{2} + a1;
        F r = -F{3} * a3 * a3 * a3 * a3 / F{256} + a3 * a3 * a2 / F{16} - a3 * a1 / F{4} + a0;
        
        sm::vvec<std::complex<F>> roots;
        
        if (std::abs(q) < EPSILON) {
            // Biquadratic case: y^4 + p*y^2 + r = 0
            // Solve as quadratic in y^2
            sm::vvec<std::complex<F>> quadRoots = solveQuadratic(F{1}, p, r);
            
            for (const auto& root : quadRoots) {
                std::complex<F> sqrtRoot = std::sqrt(root);
                roots.push_back(sqrtRoot);
                roots.push_back(-sqrtRoot);
            }
        } else {
            // Resolve using cubic resolvent: z^3 + 2*p*z^2 + (p^2 - 4*r)*z - q^2 = 0
            sm::vvec<std::complex<F>> cubicRoots = solveCubic(F{1}, F{2} * p, p * p - F{4} * r, -q * q);
            
            // Pick the real root (or root with smallest imaginary part)
            std::complex<F> m = cubicRoots[0];
            for (const auto& root : cubicRoots) {
                if (std::abs(root.imag()) < std::abs(m.imag())) {
                    m = root;
                }
            }
            
            // Calculate intermediate values
            std::complex<F> sqrtM = std::sqrt(m);
            std::complex<F> sqrtN = std::sqrt(m * m - F{4} * r);
            
            if ((sqrtM * q).real() < F{0}) {
                sqrtN = -sqrtN;
            }
            
            // Solve two quadratics
            sm::vvec<std::complex<F>> quad1 = solveQuadratic(F{1}, sqrtM.real(), (m.real() + sqrtN.real()) / F{2});
            sm::vvec<std::complex<F>> quad2 = solveQuadratic(F{1}, -sqrtM.real(), (m.real() - sqrtN.real()) / F{2});
            
            roots.insert(roots.end(), quad1.begin(), quad1.end());
            roots.insert(roots.end(), quad2.begin(), quad2.end());
        }
        
        // Transform back: x = y - a3/4
        F offset = -a3 / F{4};
        for (auto& root : roots) {
            root += offset;
        }
        
        return roots;
    }
    
    // Numerical solver for higher degrees using Durand-Kerner method
    static sm::vvec<std::complex<F>> solveDurandKerner(const sm::vvec<F>& coeffs) {
        // Durand-Kerner (Weierstrass) method for polynomial root finding
        int degree = coeffs.size() - 1;
        
        // Initialize roots in a circle
        sm::vvec<std::complex<F>> roots(degree);
        F radius = F{1} + std::abs(coeffs[degree - 1]);
        
        for (int i = 0; i < degree; ++i) {
            F angle = F{2} * F(M_PI) * F(i) / F(degree) + F{0.4};
            roots[i] = radius * std::complex<F>(std::cos(angle), std::sin(angle));
        }
        
        // Iterate
        for (int iter = 0; iter < MAX_ITERATIONS; ++iter) {
            bool converged = true;
            
            for (int i = 0; i < degree; ++i) {
                std::complex<F> numerator = evaluatePolynomialComplex(coeffs, roots[i]);
                std::complex<F> denominator(F{1}, F{0});
                
                for (int j = 0; j < degree; ++j) {
                    if (i != j) {
                        denominator *= (roots[i] - roots[j]);
                    }
                }
                
                if (std::abs(denominator) < EPSILON) {
                    continue;
                }
                
                std::complex<F> delta = numerator / denominator;
                roots[i] -= delta;
                
                if (std::abs(delta) > EPSILON) {
                    converged = false;
                }
            }
            
            if (converged) {
                break;
            }
        }
        
        return roots;
    }
    
    // Helper functions
    static F evaluatePolynomial(const sm::vvec<F>& coeffs, F x) {
        // Horner's method
        F result = F{0};
        for (int i = coeffs.size() - 1; i >= 0; --i) {
            result = result * x + coeffs[i];
        }
        return result;
    }
    
    static std::complex<F> evaluatePolynomialComplex(const sm::vvec<F>& coeffs, const std::complex<F>& z) {
        // Horner's method for complex numbers
        std::complex<F> result(F{0}, F{0});
        for (int i = coeffs.size() - 1; i >= 0; --i) {
            result = result * z + coeffs[i];
        }
        return result;
    }
    
    static void removeLeadingZeros(sm::vvec<F>& coeffs) {
        while (!coeffs.empty() && std::abs(coeffs.back()) < EPSILON) {
            coeffs.pop_back();
        }
    }
};
