// -*- C++ -*-
/*!
 * See https://github.com/sebsjames/maths
 *
 * General polynomial solver functions
 *
 * This header provides:
 * - Functions in the sm::polysolve namespace, with the top-level function being sm::polysolve::solve()
 *
 * Features:
 * - Analytical solvers for degrees 1-4:
 *   * Linear: Direct solution
 *   * Quadratic: Quadratic formula
 *   * Cubic: Cardano's method
 *   * Quartic: Ferrari's method
 * - Numerical Durand-Kerner (Weierstrass) algorithm for degree > 4
 * - Handles real and complex roots, multiple roots, degenerate cases
 *
 * Usage:
 *   #include <sm/polysolve>
 *   sm::vvec<double> coeffs = {6.0, -5.0, 1.0};         // [a0, a1, a2] for x^2 - 5x + 6 = 0
 *   sm::vvec<std::complex<double>> roots = polysolve::solve<double> (coeffs);
 *   sm::vvec<double> real_roots = polysolve::real<double> (coeffs);
 *
 * Notes:
 * - Coefficient order when presented in an array is [a0, a1, ..., an] for a_n*x^n + ... + a_1*x + a_0 = 0
 * - Functions return complex roots (may be real with zero imaginary part)
 * - All solvers return roots in sorted order: lexicographic by (real, imag)
 *
 * See polysolve_1.cpp in mathplot/maths/tests/ for a set of tests
 *
 * Authors
 * Alex Blenkinsop, using Claude Code 4.2
 * Seb James, un-fscking the AI code.
 *
 * Date Jan - Feb 2026
 */

#pragma once

#include <cstdint>
#include <complex>
#include <cmath>
#include <algorithm>
#include <stdexcept>
#include <limits>
#include <type_traits>

#include <sm/vvec>
#include <sm/vec>

namespace sm::polysolve
{
    /*
     * A helper to remove trailing zero and near-zero entries from a vvec of coefficients
     */
    template <typename T> requires std::is_floating_point_v<T>
    constexpr void remove_trailing_zeros (sm::vvec<T>& coeffs)
    {
        while (!coeffs.empty() && sm::cem::abs (coeffs.back()) < std::numeric_limits<T>::epsilon()) {
            coeffs.pop_back();
        }
    }

    /*
     * Implements Horner's method for evaluating the result of a polynomial
     */
    template <typename T> requires std::is_floating_point_v<T>
    constexpr T evaluate (const sm::vvec<T>& coeffs, const T x)
    {
        T result = T{0};
        for (int32_t i = coeffs.size() - 1; i >= 0; --i) { result = result * x + coeffs[i]; }
        return result;
    }

    /*
     * Horner's method for complex numbers
     */
    template <typename T> requires std::is_floating_point_v<T>
    constexpr std::complex<T> evaluate (const sm::vvec<T>& coeffs, const std::complex<T>& x)
    {
        std::complex<T> result = { T{0}, T{0} };
        for (int32_t i = coeffs.size() - 1; i >= 0; --i) { result = result * x + coeffs[i]; }
        return result;
    }

    /*
     * Sort complex roots in standard order:
     * Lexicographic ordering by (real, imag) components.
     * This places real roots first in ascending order, followed by complex roots.
     * Complex conjugate pairs naturally appear adjacent.
     */
    template <typename T> requires std::is_floating_point_v<T>
    constexpr void sort_roots (sm::vvec<std::complex<T>>& roots)
    {
        std::sort (roots.begin(), roots.end(), [](const std::complex<T>& a, const std::complex<T>& b) {
            if (sm::cem::abs (a.real() - b.real()) > std::numeric_limits<T>::epsilon()) {
                return a.real() < b.real();
            }
            return a.imag() < b.imag();
        });
    }


    /*
     * Return the root of the linear polynomial f = a1 x + a0
     */
    template <typename T, typename Ty=T> requires std::is_floating_point_v<T> && std::is_floating_point_v<Ty>
    constexpr sm::vvec<std::complex<T>> linear (const Ty a1, const Ty a0)
    {
        // Normalize: divide by leading coefficient
        const T a0_norm = static_cast<T>(a0 / a1);
        // a1*x + a0 = 0 => x + a0_norm = 0
        // x = -a0_norm
        return { std::complex<T>{ -a0_norm, T{0} } };
    }

    /*
     * Return the root of the complex linear polynomial f = a1 z + a0
     */
    template <typename T, typename Ty=T> requires std::is_floating_point_v<T> && std::is_floating_point_v<Ty>
    sm::vvec<std::complex<T>> linear (const std::complex<Ty>& a1, const std::complex<Ty>& a0)
    {
        // Solve a1 z + a0 = 0 with complex coefficients
        // z = -a0 / a1
        std::complex<T> a1_conv(static_cast<T>(a1.real()), static_cast<T>(a1.imag()));
        std::complex<T> a0_conv(static_cast<T>(a0.real()), static_cast<T>(a0.imag()));

        std::complex<T> root = -a0_conv / a1_conv;

        return { root };
    }

    /*
     * Return the roots of the quadratic polynomial f = a2 x^2 + a1 x + a0
     */
    template <typename T, typename Ty=T> requires std::is_floating_point_v<T> && std::is_floating_point_v<Ty>
    constexpr sm::vvec<std::complex<T>> quadratic (const Ty a2, const Ty a1, const Ty a0)
    {
        // Normalize: divide by leading coefficient a2
        const T a1_norm = static_cast<T>(a1 / a2);
        const T a0_norm = static_cast<T>(a0 / a2);
        // x^2 + a1_norm * x + a0_norm = 0
        // x = (-a1_norm +/- sqrt(a1_norm^2 - 4 * a0_norm)) / 2
        const T discriminant = a1_norm * a1_norm - T{4} * a0_norm;

        sm::vvec<std::complex<T>> roots = {};
        if (discriminant >= T{0}) {
            const T sqrtD = sm::cem::sqrt (discriminant);
            const T r1 = (-a1_norm + sqrtD) / T{2};
            const T r2 = (-a1_norm - sqrtD) / T{2};
            roots = { std::complex<T>{ r1, T{0} }, std::complex<T>{ r2, T{0} } };
        } else {
            const T real_part = -a1_norm / T{2};
            const T imag_part = sm::cem::sqrt (-discriminant) / T{2};
            roots = { std::complex<T>{ real_part, -imag_part }, std::complex<T>{ real_part, imag_part } };
        }
        polysolve::sort_roots (roots);
        return roots;
    }

    /*
     * Return the roots of the complex quadratic polynomial f = a2 z^2 + a1 z + a0
     */
    template <typename T, typename Ty=T> requires std::is_floating_point_v<T> && std::is_floating_point_v<Ty>
    sm::vvec<std::complex<T>> quadratic (const std::complex<Ty>& a2, const std::complex<Ty>& a1, const std::complex<Ty>& a0)
    {
        // Solve a2 z^2 + a1 z + a0 = 0 with complex coefficients
        // z = (-a1 +/- sqrt(a1^2 - 4 a2 a0)) / (2 a2)
        const std::complex<T> a2_conv = { static_cast<T>(a2.real()), static_cast<T>(a2.imag()) };
        const std::complex<T> a1_conv = { static_cast<T>(a1.real()), static_cast<T>(a1.imag()) };
        const std::complex<T> a0_conv = { static_cast<T>(a0.real()), static_cast<T>(a0.imag()) };

        const std::complex<T> discriminant = a1_conv * a1_conv - T{4} * a2_conv * a0_conv;
        const std::complex<T> sqrt_disc = std::sqrt (discriminant);

        const std::complex<T> denom = T{2} * a2_conv;
        const std::complex<T> root1 = (-a1_conv + sqrt_disc) / denom;
        const std::complex<T> root2 = (-a1_conv - sqrt_disc) / denom;

        sm::vvec<std::complex<T>> roots = { root1, root2 };
        polysolve::sort_roots (roots);
        return roots;
    }

    /*
     * Return the roots of the cubic polynomial f = a3 x^3 + a2 x^2 + a1 x + a0
     *
     * Follows the Numerical Recipes in C, 2nd ed. description of Cardano's method (p 184)
     */
    template <typename T, typename Ty=T> requires std::is_floating_point_v<T> && std::is_floating_point_v<Ty>
    sm::vvec<std::complex<T>> cubic (const Ty a3, const Ty a2, const Ty a1, const Ty a0)
    {
        const T a2_norm = static_cast<T>(a2 / a3);
        const T a1_norm = static_cast<T>(a1 / a3);
        const T a0_norm = static_cast<T>(a0 / a3);
        const T q = ((a2_norm * a2_norm) - (T{3} * a1_norm)) / T{9};
        const T r = ((T{2} * a2_norm * a2_norm * a2_norm) - (T{9} * a2_norm * a1_norm) + (T{27} * a0_norm)) / T{54};
        const T q3 = q * q * q;
        const T r2 = r * r;
        const T a2n_over_3 = a2_norm / T{3};

        sm::vvec<std::complex<T>> roots = {};
        if (r2 < q3) {
            // three real roots
            const T theta = sm::cem::acos (r / sm::cem::sqrt (q3));
            const T m2rootq = -T{2} * sm::cem::sqrt (q);
            roots.push_back (std::complex<T>{ m2rootq * sm::cem::cos (theta / T{3}) - a2n_over_3,                               T{0} });
            roots.push_back (std::complex<T>{ m2rootq * sm::cem::cos ((theta + sm::mathconst<T>::two_pi) / T{3})  - a2n_over_3, T{0} });
            roots.push_back (std::complex<T>{ m2rootq * sm::cem::cos ((theta - sm::mathconst<T>::two_pi) / T{3})  - a2n_over_3, T{0} });
        } else {
            constexpr T one_third = T{1} / T{3};
            const T a = -sm::cem::sgn (r) * std::pow ((sm::cem::abs (r) + sm::cem::sqrt (r2 - q3)), one_third);
            const T b = (a == T{0} ? T{0} : (q / a));
            roots.push_back (std::complex<T>{ (a + b) - a2n_over_3          ,  T{0}                                      });
            roots.push_back (std::complex<T>{ T{-0.5} * (a + b) - a2n_over_3,  sm::mathconst<T>::root_3_over_2 * (a - b) });
            roots.push_back (std::complex<T>{ T{-0.5} * (a + b) - a2n_over_3, -sm::mathconst<T>::root_3_over_2 * (a - b) });
        }

        polysolve::sort_roots (roots);
        return roots;
    }

    /*
     * Return the roots of the quartic polynomial f = a4 x^4 + a3 x^3 + a2 x^2 + a1 x + a0
     */
    template <typename T, typename Ty=T> requires std::is_floating_point_v<T> && std::is_floating_point_v<Ty>
    sm::vvec<std::complex<T>> quartic (const Ty a4, const Ty a3, const Ty a2, const Ty a1, const Ty a0)
    {
        // Normalize: divide by leading coefficient a4
        const T a3_norm = static_cast<T>(a3 / a4);
        const T a2_norm = static_cast<T>(a2 / a4);
        const T a1_norm = static_cast<T>(a1 / a4);
        const T a0_norm = static_cast<T>(a0 / a4);
        // Solve x^4 + a3_norm*x^3 + a2_norm*x^2 + a1_norm*x + a0_norm = 0 using Ferrari's method

        // Convert to depressed quartic: y^4 + p*y^2 + q*y + r = 0
        const T p = a2_norm - T{3} * a3_norm * a3_norm / T{8};
        const T q = a3_norm * a3_norm * a3_norm / T{8} - a3_norm * a2_norm / T{2} + a1_norm;
        const T r = -T{3} * a3_norm * a3_norm * a3_norm * a3_norm / T{256} + a3_norm * a3_norm * a2_norm / T{16} - a3_norm * a1_norm / T{4} + a0_norm;

        sm::vvec<std::complex<T>> roots = {};

        if (sm::cem::abs (q) < std::numeric_limits<T>::epsilon()) {
            // Biquadratic case: y^4 + p * y^2 + r = 0
            // Solve as quadratic in y^2
            sm::vvec<std::complex<T>> quad_roots = polysolve::quadratic<T> (T{1}, p, r);

            for (const auto& root : quad_roots) {
                const std::complex<T> sqrt_root = std::sqrt (root);
                roots.push_back (sqrt_root);
                roots.push_back (-sqrt_root);
            }
        } else {
            // Resolve using cubic resolvent: z^3 + 2 * p * z^2 + (p^2 - 4 * r) * z - q^2 = 0
            sm::vvec<std::complex<T>> cubic_roots = polysolve::cubic<T> (T{1}, T{2} * p, p * p - T{4} * r, -q * q);

            // Pick the real root (or root with smallest imaginary part)
            std::complex<T> m = cubic_roots[0];
            for (const auto& root : cubic_roots) {
                if (std::abs (root.imag()) < std::abs (m.imag())) { m = root; }
            }

            // Ferrari's factorization: y^4 + p * y^2 + q * y + r = (y^2 + s * y + t)(y^2 - s * y + u)
            // Where: s^2 = m, t + u = p + m, t * u = r
            const std::complex<T> s = std::sqrt(m);

            // Find t and u as roots of: z^2 - (p + m) * z + r = 0
            const std::complex<T> sum_tu = p + m;
            const std::complex<T> prod_tu = { r, T{0} };
            sm::vvec<std::complex<T>> tu_roots = polysolve::quadratic<T> (std::complex<T>{ T{1}, T{0} }, -sum_tu, prod_tu);
            const std::complex<T>& t = tu_roots[0];
            const std::complex<T>& u = tu_roots[1];

            // Verify and swap if needed to ensure s(u-t) = q
            const std::complex<T> q_check = s * (u - t);
            if (std::abs (q_check - std::complex<T>{ q, T{0} }) > std::abs (s * (t - u) - std::complex<T>{ q, T{0} })) {
                std::swap (tu_roots[0], tu_roots[1]);
            }

            // Solve two quadratics: y^2 + s * y + t = 0 and y^2 - s * y + u = 0
            sm::vvec<std::complex<T>> quad1 = polysolve::quadratic<T> (std::complex<T>{ T{1}, T{0} }, s, t);
            sm::vvec<std::complex<T>> quad2 = polysolve::quadratic<T> (std::complex<T>{ T{1}, T{0} }, -s, u);

            roots.insert (roots.end(), quad1.begin(), quad1.end());
            roots.insert (roots.end(), quad2.begin(), quad2.end());
        }

        // Transform back: x = y - a3_norm/4
        const T offset = -a3_norm / T{4};
        for (auto& root : roots) { root += offset; }

        polysolve::sort_roots (roots);
        return roots;
    }

    /*
     * Numerical solver for higher degrees using Durand-Kerner (Weierstrass) method.
     *
     * \param coeffs is a vector of coefficients with coeffs[0] being the zeroth-order coefficient
     * (the scalar offset), coeffs[1] the coefficient of x, coeffs[2] the coefficient of x^2, and so
     * on.
     */
    template <typename T, typename Ty=T> requires std::is_floating_point_v<T> && std::is_floating_point_v<Ty>
    sm::vvec<std::complex<T>> high_order (const sm::vvec<Ty>& coeffs)
    {
        const int32_t degree = coeffs.size() - 1;

        // Convert coeffs to type T
        sm::vvec<T> c;
        if constexpr (std::is_same_v<Ty, T> == true) {
            c = coeffs;
        } else {
            c = coeffs.template as<T>();
        }

        // Initialize roots in a circle
        sm::vvec<std::complex<T>> roots (degree);
        const T radius = T{1} + sm::cem::abs (c[degree - 1]);

        for (int32_t i = 0; i < degree; ++i) {
            const T angle = sm::mathconst<T>::two_pi * T(i) / T(degree) + T{0.4};
            roots[i] = radius * std::complex<T>{ sm::cem::cos (angle), sm::cem::sin (angle) };
        }

        // The iterative solver
        for (int32_t iter = 0; iter < 100; ++iter) {
            bool converged = true;
            for (int32_t i = 0; i < degree; ++i) {
                std::complex<T> numerator = polysolve::evaluate<T> (c, roots[i]);
                std::complex<T> denominator = { T{1}, T{0} };
                for (int32_t j = 0; j < degree; ++j) {
                    if (i != j) { denominator *= (roots[i] - roots[j]); }
                }
                if (std::abs (denominator) < std::numeric_limits<T>::epsilon()) { continue; }
                std::complex<T> delta = numerator / denominator;
                roots[i] -= delta;
                if (std::abs (delta) > std::numeric_limits<T>::epsilon()) { converged = false; }
            }
            if (converged) { break; }
        }

        polysolve::sort_roots (roots);
        return roots;
    }

    /*
     * Solve polynomial: a[n]*x^n + a[n-1]*x^(n-1) + ... + a[1]*x + a[0] = 0
     * \tparam Ty Type of input coefficients
     * \tparam N Size of coefficient array (degree + 1)
     * \tparam T Type of output roots, and type used in solvers (defaults to input type Ty if not specified)
     * \param coeffs Coefficients from lowest to highest degree [a0, a1, ..., an]
     * \return Vector of complex roots sorted lexicographically by (real, imag).
     *         Real roots appear first in ascending order, followed by complex roots.
     */
    template <typename T, uint32_t N, typename Ty = T> requires (N >= 1) && std::is_floating_point_v<T> && std::is_floating_point_v<Ty>
    sm::vvec<std::complex<T>> solve (const sm::vec<Ty, N + 1>& coeffs)
    {
        // Make a copy of coefficients in type T
        sm::vvec<T> c (N + 1, T{0});
        for (uint32_t i = 0u; i < N + 1; ++i) { c[i] = static_cast<T>(coeffs[i]); }
        polysolve::remove_trailing_zeros (c);

        if (c.empty() || (c.size() == 1 && sm::cem::abs (c[0]) < std::numeric_limits<T>::epsilon())) {
            throw std::invalid_argument("All coefficients are zero");
        }

        const int32_t degree = c.size() - 1;

        // Handle constant polynomial which has no roots
        if (degree == 0) { return {}; }

        // Use analytical solutions for degrees 1-4, numerical method for higher orders
        if constexpr (N == 1) {
            return polysolve::linear<T> (c[1], c[0]);
        } else if constexpr (N == 2) {
            return polysolve::quadratic<T> (c[2], c[1], c[0]);
        } else if constexpr (N == 3) {
            return polysolve::cubic<T> (c[3], c[2], c[1], c[0]);
        } else if constexpr (N == 4) {
            return polysolve::quartic<T> (c[4], c[3], c[2], c[1], c[0]);
        } else {
            return polysolve::high_order<T> (c);
        }
    }

    /*
     * Solve polynomial with runtime degree determination
     * \tparam T Type of output roots
     * \tparam Ty Type of input coefficients
     * \param coeffs Coefficients from lowest to highest degree [a0, a1, ..., an]
     * \return Vector of complex roots sorted lexicographically by (real, imag).
     *         Real roots appear first in ascending order, followed by complex roots.
     */
    template <typename T, typename Ty=T> requires std::is_floating_point_v<T> && std::is_floating_point_v<Ty>
    sm::vvec<std::complex<T>> solve (const sm::vvec<Ty>& coeffs)
    {
        if (coeffs.empty()) { throw std::invalid_argument ("Empty coefficient vector"); }

        // Make a copy of coefficients in type T
        sm::vvec<T> c;
        if constexpr (std::is_same_v<Ty, T> == true) {
            c = coeffs;
        } else {
            c = coeffs.template as<T>();
        }

        polysolve::remove_trailing_zeros (c);

        if (c.empty() || (c.size() == 1 && sm::cem::abs (c[0]) < std::numeric_limits<T>::epsilon())) {
            throw std::invalid_argument ("All coefficients are zero");
        }

        const int32_t degree = c.size() - 1;

        // Handle constant polynomial which has no roots
        if (degree == 0) { return {}; }

        // Use analytical solutions for degrees 1-4, numerical method for higher orders
        if (degree == 1) {
            return polysolve::linear<T> (c[1], c[0]);
        } else if (degree == 2) {
            return polysolve::quadratic<T> (c[2], c[1], c[0]);
        } else if (degree == 3) {
            return polysolve::cubic<T> (c[3], c[2], c[1], c[0]);
        } else if (degree == 4) {
            return polysolve::quartic<T> (c[4], c[3], c[2], c[1], c[0]);
        } else {
            return polysolve::high_order<T> (c);
        }
    }

    /*
     * Get only real roots (imaginary part < tolerance)
     * \param coeffs Coefficients from lowest to highest degree
     * \param tolerance Threshold for considering a root as real
     * \return Vector of real roots in ascending order
     */
    template <typename T, typename Ty = T> requires std::is_floating_point_v<T> && std::is_floating_point_v<Ty>
    constexpr sm::vvec<T> real (const sm::vvec<Ty>& coeffs, const T tolerance = T{100} * std::numeric_limits<T>::epsilon())
    {
        sm::vvec<std::complex<T>> complex_roots = polysolve::solve<T, Ty> (coeffs);
        sm::vvec<T> real_roots = {};
        for (const std::complex<T>& root : complex_roots) {
            if (sm::cem::abs (root.imag()) < tolerance) { real_roots.push_back (root.real()); }
        }
        std::sort (real_roots.begin(), real_roots.end());
        return real_roots;
    }

    /*
     * Filter and return only real roots from polynomial solution using sm::vec
     * \tparam Ty Type of input coefficients
     * \tparam N Size of coefficient array (degree + 1)
     * \tparam T Type of output (deduced from Ty by default)
     * \param coeffs Coefficients from lowest to highest degree
     * \param tolerance Threshold for considering a root as real
     * \return Vector of real roots in ascending order
     */
    template <typename T, uint32_t N, typename Ty = T> requires std::is_floating_point_v<T> && std::is_floating_point_v<Ty>
    constexpr sm::vvec<T> real (const sm::vec<Ty, N + 1>& coeffs, const T tolerance = T{100} * std::numeric_limits<T>::epsilon())
    {
        sm::vvec<std::complex<T>> complex_roots = polysolve::solve<T, N, Ty> (coeffs);
        sm::vvec<T> real_roots = {};
        for (const std::complex<T>& root : complex_roots) {
            if (sm::cem::abs (root.imag()) < tolerance) { real_roots.push_back (root.real()); }
        }
        std::sort (real_roots.begin(), real_roots.end());
        return real_roots;
    }

}   // end of sm::polysolve namespace
