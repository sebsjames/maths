#include <iostream>
#include <cmath>
#include <iomanip>
#include <sm/mat22>

template <typename T, uint32_t N = 2>
int test_vector (sm::vec<T, N>& expected_vec, typename sm::mat22<T>::eigenpair& ep)
{
    int rtn = 0;
    constexpr T numeric_thresh = 1e-8;

    bool elements_negated = false;
    for (uint32_t j = 0; j < N; ++j) {
        T element = std::real (ep.eigenvector[j]);
        std::cout << "Vector for Eigenvalue " << ep.eigenvalue << " element " << j << " ";

        // While our eigenvector will be normalized, we may validly obtain the negative of
        // the vector generated by other libraries, so test +element and -element against the
        // expected values here. IF one element is negated, ALL must be negated.
        if (j == 0) {
            std::cout << "Comparing element = " << element << " with +/- expected element: " << expected_vec[j] << std::endl;
            if (std::abs (element - expected_vec[j]) > numeric_thresh
                && std::abs (-element - expected_vec[j]) > numeric_thresh) {
                std::cout << " Eigenvector test failed\n";
                --rtn;
            } else {
                if (std::abs (element - expected_vec[j]) > numeric_thresh) {
                    std::cout << "Expected vector elements appear to be NEGATED\n";
                    elements_negated = true;
                }
            }
        } else {
            if (elements_negated) {
                std::cout << "Comparing element = " << element << " with negative of expected element: " << expected_vec[j] << std::endl;

                if (std::abs (-element - expected_vec[j]) > numeric_thresh) {
                    std::cout << " Eigenvector test failed\n";
                    --rtn;
                }
            } else {
                std::cout << "Comparing element = " << element << " with expected element: " << expected_vec[j] << std::endl;
                if (std::abs (element - expected_vec[j]) > numeric_thresh) {
                    std::cout << " Eigenvector test failed\n";
                    --rtn;
                }
            }
        }
    }

    return rtn;
}

template <typename T, uint32_t N = 2>
int test_matrix (const sm::mat22<T>& A, sm::vec<T, N>& exptd_eigenvalues, sm::vec<sm::vec<T, N>, N>& exptd_eigenvectors)
{
    // A numeric threshold for comparing with numbers pulled in from another library
    constexpr double numeric_thresh = 1e-8;

    int rtn = 0;
    std::cout << "Testing Matrix:\n" << A << std::endl;
    sm::vec<typename sm::mat22<T>::eigenpair, N> eps = A.eigenpairs();

    std::cout << "Eigenvalues:\n";
    for (uint32_t i = 0; i < N; ++i) { std::cout << eps[i].eigenvalue << "\n"; }
    std::cout << std::endl;

    for (uint32_t i = 0; i < N; ++i) {
        std::cout << "Eigenvalue " << eps[i].eigenvalue;
        std::cout << " corresponds to Eigenvector ";
        std::cout << "[";
        for (uint32_t j = 0; j < N; ++j) {
            std::cout << eps[i].eigenvector[j] << " ";
        }
        std::cout << "]" << std::endl;
    }

    for (uint32_t i = 0; i < N; ++i) {
        if (std::abs(eps[i].eigenvalue - exptd_eigenvalues[i]) > numeric_thresh) {
            std::cout << "Eigenvalue test failed\n";
            --rtn;
        }

        rtn += test_vector<T, N> (exptd_eigenvectors[i], eps[i]);
    }

    return rtn;
}

int main()
{
    constexpr uint32_t N = 2;
    int rtn = 0;

    std::cout << "=== mat22 Eigenvector Tests ===\n\n";

    // Test 1: An example matrix
    std::cout << "Test 1: An example matrix\n";
    sm::mat22<double> A = {
        1.00671141, -0.11835884,
        -0.11835884,  1.00671141
    };
    sm::vec<double, N> exptd_eigenvalues = { 1.12507025, 0.88835257 };
    sm::vec<sm::vec<double, N>, N> exptd_eigenvectors = {
        sm::vec<double, N>{ 0.70710678, -0.70710678 },
        sm::vec<double, N>{ 0.70710678, 0.70710678 }
    };

    rtn += test_matrix<double, 2> (A, exptd_eigenvalues, exptd_eigenvectors);

    std::cout << "\nTest 2: Another example matrix (diagonal)\n";
    A = { 1, 0, 0, 2 };
    rtn += test_matrix<double, 2> (A, exptd_eigenvalues, exptd_eigenvectors);


    std::cout << (rtn == 0 ? "\nAll tests passed\n" : "\nSome tests failed\n");
    return rtn;
}
